
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>SotoSeattle</title>
  <meta name="author" content="Javier Soto">

  
  <meta name="description" content="We continue with Assignment 5 from Prof. Koller’s Coursera course: “Probabilistic Graphical Models”. I am including the explanation from the &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://sotoseattle.github.io/blog/page/7">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="" rel="alternate" title="SotoSeattle" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["$$","$$"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner">
	<div class="header-title"><a href="/">SotoSeattle</a></div>


	<br><div class="header-subtitle">Developer of software, ideas, startups</div>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<!--   <li><a href="" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li> -->
  
  <li class='icon'>
    <a href="https://github.com/sotoseattle/">
      <img src="/images/logos/github_icon.png" width="36" height="27">
      </img>
    </a>
  </li>
  <li class='icon'>
    <a href="https://www.linkedin.com/in/sotoseattle/">
      <img src="/images/logos/linkedin-256.png"  width="27" height="27">
      </img>
    </a>
  </li>
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:sotoseattle.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
<!--   <li><a href="projects/">Projects</a></li> -->
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/images/Javier_Soto_resume.pdf">Resume</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/02/15/MCMC-MH-SW/">MCMC MH Swendsen Wang</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-02-15T08:01:00-08:00" pubdate data-updated="true">Feb 15<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We continue with Assignment 5 from Prof. Koller’s Coursera course: “Probabilistic Graphical Models”. I am including the explanation from the assignment paper because it is the most clear explanation I have found for the Swendsen Wang sampling method, which is a hair rasing trip in on itself.</p>

<h2 id="theory">Theory</h2>

<p>In Ising models and image segmentation applications, pairwise Markov networks are frequently used. This means specially for strong potentials adjacent variables tend to take on the same values. This makes it hard to explore the space for possible assignments by changing the value of one variable at a time, like Gibbs does. The Swendsen-Wang algorithm has been specifically designed for this kind of networks and overcomes this difficulty by changing, at the same time, a group of adjacent variables that have the same value.</p>

<p>In Swendsen-Wang, we start with a model that has variables connected in pairwise factors in a Markov graph. All the variables can take on the same values. To do MCMC, we start as usual in some state x. To get to the next state, we start with the graph. We break all the edges between variables that have different values. Then, we also break the rest of the edges between any nodes i and j with probability <script type="math/tex">(1−q_{i,j})</script>, where <script type="math/tex">q_{i,j}</script> is a probability that can depend on i and j but not their current assignment. </p>

<p>Once we’ve broken all those edges, we’re left with a graph with connected groups of variables, with all variables in a group sharing the same assignment. We randomly pick one with a uniform distribution. That’s Y . We choose a new assignment, using a probability distribution R. With the new assignment to the variables in Y , we now have the new state x’; in other words, the new assignment x’ is the same as x, except that the variables in Y have changed value. As with all MH, we accept the state with a probability A.</p>

<p><img class="center" src="/images/feb14/SW_procedure.png" width="500" title="Swendsen Wang Procedure 1" /></p>

<p>To compute Q, R, and A, we use the following equations. Let C(Y|x) be the probability that a set Y is selected to be updated using this procedure, given the current state is x. Then we somehow divine Q(x → x’), the chance that we’ll try a transition from x to x’ by changing Y , as the following:</p>

<script type="math/tex; mode=display">
Q(x \rightarrow x') = C(Y|x) R(Y = l'|x_Y )
</script>

<p>So we can compute the ratio for A (acceptance probability):</p>

<script type="math/tex; mode=display">
\frac{Q(x' \rightarrow x)}{Q(x \rightarrow x')} =\frac{C(Y|x') R(Y = l|x'_Y )}{C(Y|x) R(Y = l'|x_Y )}
</script>

<p>And we realize that obviously the following is a truism:</p>

<script type="math/tex; mode=display">
\frac{C(Y|x')}{C(Y|x)} = \frac{\prod_{(i,j) \in \epsilon (Y, X_{l'}^{'}-Y)}(1 - q_{i,j})}{\prod_{(i,j) \in \epsilon (Y, X_{l}-Y)}(1 - q_{i,j})}
</script>

<p>Where: <script type="math/tex">X_l</script> is the set of vertices with label l in x, <script type="math/tex">X'_{l'}</script> is the set of vertices with label l’ in x’; and where <script type="math/tex">\epsilon(Y,Z)</script> (between two disjoint sets Y,Z) is the set of edges connecting nodes in Y to nodes in Z.</p>

<h2 id="sw-uniform-variant">SW Uniform variant</h2>

<p>Although the intuition behind breaking the graph and changing the assignment of a connected component makes sense, coming up with Q and R are beyond my grasp. Nevertheless, we compute SW in two variants. The first one is easy, it uses a Q that is uniform, so we set all the <script type="math/tex">q_{ij}</script> to 0.5 (our Ising net is all binomial). We also set R to be uniform. Nevertheless Let’s go step by step:</p>

<p>The first thing we have to take into consideration is to create a data structure in our MCMC_MHSW object that holds, for each edge between nodes i and j the value of <script type="math/tex">q_{ij}</script>. In our variant all Q are equal, being the uniform.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Q by edges</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="bp">self</span><span class="o">.</span><span class="n">q_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
</span><span class="line"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">V</span><span class="p">):</span>
</span><span class="line">    <span class="bp">self</span><span class="o">.</span><span class="n">q_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line">    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span><span class="line">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
</span><span class="line">            <span class="bp">self</span><span class="o">.</span><span class="n">q_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now we start processing. Given the graph and a complete assignment we remove the edges connecting variables that have different values. Also, we take the opportunity to break edges based on the probability Q.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Breaking Edges Based on Assignment</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">common_components_and_Q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ass</span><span class="p">):</span>
</span><span class="line">    <span class="sd">&#39;&#39;&#39;return connected edges between nodes that share assignment, and pass Q probability&#39;&#39;&#39;</span>
</span><span class="line">    <span class="n">edges</span> <span class="o">=</span> <span class="p">[[]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">V</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_pass_edges</span><span class="p">:</span>
</span><span class="line">        <span class="k">if</span> <span class="n">ass</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">==</span><span class="n">ass</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
</span><span class="line">            <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class="line">            <span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class="line">    <span class="k">return</span> <span class="n">edges</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>With this new graph (the same as the original but with rearranged edges) we need is a way to find its connected components. That is easy with DFS (Depth First Search) and the Princeton Algorithm’s course from Coursera. Given a graph G we can find how many components there are, and to which one each variable belongs.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Connected Components</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">CC</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">dni</span> <span class="o">=</span> <span class="p">[[]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">V</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">marked</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">V</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">[[]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">V</span>
</span><span class="line">        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">V</span><span class="p">):</span>
</span><span class="line">            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
</span><span class="line">                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class="line">                <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">dni</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line">        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">):</span>
</span><span class="line">                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The code for a method to return a new assignment begins to take form:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Finding a new Assignment</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">MH_Swendsen_Wang</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">):</span>
</span><span class="line">    <span class="c"># build new graph breaking edges where nodes differ in assignment and by Q</span>
</span><span class="line">    <span class="n">G_prime</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
</span><span class="line">    <span class="n">G_prime</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rearrange_edges</span><span class="p">(</span><span class="n">from_ass</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c"># get connected components</span>
</span><span class="line">    <span class="n">common_comps</span> <span class="o">=</span> <span class="n">CC</span><span class="p">(</span><span class="n">G_prime</span><span class="p">)</span>
</span><span class="line">    <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>With the components identified we can select one (randomly), and retrieve all its variables.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>cont</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">MH_Swendsen_Wang</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">):</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="c"># select a common component randomly</span>
</span><span class="line">    <span class="n">Y_index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">common_comps</span><span class="o">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line">    <span class="n">Y_v_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">common_comps</span><span class="o">.</span><span class="n">dni</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">Y_index</span><span class="p">]</span>
</span><span class="line">    <span class="n">cardio</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">totCard</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Y_v_id</span><span class="p">]</span>
</span><span class="line">    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">cardio</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="c"># check all have same ass and cardinality</span>
</span><span class="line">    <span class="n">d</span> <span class="o">=</span> <span class="n">cardio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class="line">    <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We compute the R (actually the log of R for underflows). In our case of first variant and given that all variables are bianry, this  uniform distribution R becomes <code>[log(0.5), log(0.5)]</code>. The old value of Y can be taken from any variable of Y (we choose whichever is first), and the new assignment is randomly extracted from the R distribution. The new complete assignment becomes then the same as the original except for the variables in Y, which take now on the new value derived from R.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>cont</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">MH_Swendsen_Wang</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">):</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="n">logR</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">d</span><span class="p">)]</span><span class="o">*</span><span class="n">d</span>
</span><span class="line">    <span class="n">old_value</span> <span class="o">=</span> <span class="n">from_ass</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">Y_v_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
</span><span class="line">    <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randSampleDist</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logR</span><span class="p">))</span>
</span><span class="line">    <span class="n">to_ass</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">new_value</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">Y_v_id</span> <span class="k">else</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">from_ass</span><span class="p">)</span>
</span><span class="line">    <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now comes the part of the messy equation and the epsilons. We need to compute the ratio of the products of Qs for all edges. We do it in log space with sums.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>cont</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">MH_Swendsen_Wang</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">):</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="c"># log-ratio of the prob of picking Y given we transition from_ass to_ass</span>
</span><span class="line">    <span class="c"># we need to iterate over all edges</span>
</span><span class="line">    <span class="n">log_QY_ratio</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_pass_edges</span><span class="p">:</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">Y_v_id</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Y_v_id</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Y_v_id</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Y_v_id</span><span class="p">):</span>
</span><span class="line">            <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class="line">            <span class="k">if</span> <span class="n">from_ass</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">old_value</span> <span class="ow">and</span> <span class="n">from_ass</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="n">old_value</span><span class="p">:</span>
</span><span class="line">                <span class="n">log_QY_ratio</span> <span class="o">=</span> <span class="n">log_QY_ratio</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
</span><span class="line">            <span class="k">if</span> <span class="n">to_ass</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_value</span> <span class="ow">and</span> <span class="n">to_ass</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_value</span><span class="p">:</span>
</span><span class="line">                <span class="n">log_QY_ratio</span> <span class="o">=</span> <span class="n">log_QY_ratio</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
</span><span class="line">    <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Finally, we have everything to compute A. We compute the stationary probabilities as we did with MH Uniform, easy. Then the acceptance probability just follows the theoretical formula given before. We check randomly if pass or not the acceptance threshold, and if we do we send the new complete assignment as the new sample (if not , we stay put).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>cont</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">MH_Swendsen_Wang</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">):</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="n">acceptance</span><span class="p">,</span> <span class="n">from_pi</span><span class="p">,</span> <span class="n">to_pi</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
</span><span class="line">    <span class="k">for</span> <span class="n">fu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
</span><span class="line">        <span class="n">from_pi</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">FactorOperations</span><span class="o">.</span><span class="n">reduce_to_value</span><span class="p">(</span><span class="n">fu</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">))</span>
</span><span class="line">        <span class="n">to_pi</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">FactorOperations</span><span class="o">.</span><span class="n">reduce_to_value</span><span class="p">(</span><span class="n">fu</span><span class="p">,</span> <span class="n">to_ass</span><span class="p">))</span>
</span><span class="line">    <span class="n">acceptance</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">to_pi</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">from_pi</span><span class="p">))</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_QY_ratio</span><span class="p">)</span><span class="o">*</span>\
</span><span class="line">                      <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logR</span><span class="p">[</span><span class="n">old_value</span><span class="p">])</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logR</span><span class="p">[</span><span class="n">new_value</span><span class="p">])</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">acceptance</span><span class="p">:</span>
</span><span class="line">        <span class="n">from_ass</span> <span class="o">=</span> <span class="n">to_ass</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">from_ass</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="analysis">Analysis</h2>

<p>Following the same procedures and initial inputs as we did for Gibbs and MH Uniform we produce the following chart for comparison purposes. All pretty impressive.</p>

<p>Mixing time:</p>

<p><img class="center" src="/images/feb14/MHSW_1_mix.png" width="500" title="Mixing Windows Run 1" /></p>

<p>Sample Size:</p>

<p><img class="center" src="/images/feb14/MHSW_1_size.png" width="500" title="Sample Size Run 1" /></p>

<p>Marginals Convergence for the extreme case [0.95, 0.05]:</p>

<p><img class="center" src="/images/feb14/MHSW_1_cross.png" width="500" /></p>

<p>Histogram of dist to true marginal based on 100 runs on 16 node Ising:</p>

<p><img class="center" src="/images/feb14/MHSW_1_hist.png" width="500" /></p>

<p>Although the hsitogram runs over 70,000 is overkill (WS arrives at the stationary distribution way earlier), the results are impressive. An Average error of 0.04 with standard deviation of 0.02. All very impressive. Cannot wait to see if the Swendsen Wang variant 2 achieves even better results!</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/02/13/MCMC-MH-Uniform/">MCMC MH Uniform</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-02-13T08:01:00-08:00" pubdate data-updated="true">Feb 13<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The code for a Q based on the Uniform distribution has three steps:</p>

<ul>
  <li>come up with a new complete assignment out of the blue (literally)</li>
  <li>compute the acceptance probability. When we compute π(x’)Q(x’ → x), π is the joint probability reduced by the complete assignment (unormalized), meaning the total probability of having that assignment. The question is, how do I compute Q(x’ → x)? Since it is the uniform distribution, Q(x’ → x) == Q(x → x’) == constant, so it cancels out and I only need to compute the ratio of π(x’) / π(x).</li>
  <li>decide with the new acceptance if, like The Clash asks, should we stay or should we go.</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Q from Uniform dist</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">MH_Uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">):</span>
</span><span class="line">    <span class="c"># get a random complete assignment from uniform distribution</span>
</span><span class="line">    <span class="n">cardio</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">totCard</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">]</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">floor</span><span class="p">([</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="n">cardio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cardio</span><span class="p">))])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</span><span class="line">    <span class="n">to_ass</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">e</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">v</span><span class="p">))</span>
</span><span class="line">
</span><span class="line">    <span class="c"># compute the probabilities of transitions</span>
</span><span class="line">    <span class="n">fwd</span><span class="p">,</span> <span class="n">bwd</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
</span><span class="line">    <span class="k">for</span> <span class="n">fu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
</span><span class="line">        <span class="n">fwd</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">FactorOperations</span><span class="o">.</span><span class="n">reduce_to_value</span><span class="p">(</span><span class="n">fu</span><span class="p">,</span> <span class="n">to_ass</span><span class="p">))</span>
</span><span class="line">        <span class="n">bwd</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">FactorOperations</span><span class="o">.</span><span class="n">reduce_to_value</span><span class="p">(</span><span class="n">fu</span><span class="p">,</span> <span class="n">from_ass</span><span class="p">))</span>
</span><span class="line">
</span><span class="line">    <span class="c"># compute acceptance probability and return the new state</span>
</span><span class="line">    <span class="n">p_acceptance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">fwd</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bwd</span><span class="p">))])</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p_acceptance</span><span class="p">:</span>
</span><span class="line">        <span class="n">from_ass</span> <span class="o">=</span> <span class="n">to_ass</span>
</span><span class="line">    <span class="k">return</span> <span class="n">from_ass</span>
</span><span class="line"><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>To speed up the process, I have added a new utility function to Factor Operations, to extract the potential/probability value of a complete assigment from a given factor. It is the same as reducing, but instead of giving back a reduced factor, since we have a complete assignment (all variables have assignments) we return a value (float).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Get Factor Value of Complete Assignment</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">reduce_to_value</span><span class="p">(</span><span class="n">fA</span><span class="p">,</span> <span class="n">evidence</span><span class="p">):</span>
</span><span class="line">    <span class="sd">&#39;&#39;&#39;reduce factor by complete assignment to a single value&#39;&#39;&#39;</span>
</span><span class="line">    <span class="n">complete_ass</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">evidence</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fA</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
</span><span class="line">    <span class="k">return</span> <span class="n">fA</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">complete_ass</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="mixing">Mixing</h2>

<p>As before we run the MCMCMHU to collect a total of 70,000 samples. The initial assignment is initialized to all ones. </p>

<p>Now we get subsets every 1,000 samples of size 10,000. That is 59 windows of 10,000 samples collected after different mixing times.</p>

<p>Ploting the difference between the exact marginal and our estimated marginals of the three variables (number 0 as red, 4 as blue, and 8 as green), we have the following charts (from two different runs).</p>

<div>
	<img class="left" src="/images/feb14/MHU_mix.png" width="425" title="Mixing Windows Run 1" />
	<img class="right" src="/images/feb14/MHU_mixB.png" width="425" title="Mixing Windows Run 2" />
</div>
<p><br /></p>

<p>No clear mixing threshold.</p>

<h2 id="sample-size">Sample size</h2>

<p>Following the previous settings but fixing the mixing time to 1,000, we can plot the difference between exact and estimated marginals as we collect more samples. From the charts (two different runs) we see that it converges beyond 20,000. </p>

<div>
	<img class="left" src="/images/feb14/MHU_size.png" width="425" title="Sample Size Run 1" />
	<img class="right" src="/images/feb14/MHU_sizeB.png" width="425" title="Sample Size Run 2" />
</div>
<p><br /></p>

<p>Nevertheless, it seems to work worse than Gibbs.</p>

<h2 id="marginals-convergence">Marginals Convergence</h2>

<p>We again run twice the model and see how well the estimated marginals converge across runs. All models are Ising grids with 9 variables, have mixing time of 7,000 and sample size of 10,000. </p>

<div>
	<img class="left" src="/images/feb14/MHU_compare_runs_0703.png" width="425" />
	<img class="right" src="/images/feb14/MHU_compare_runs_102.png" width="425" />
	<img class="center" src="/images/feb14/MHU_compare_runs_095005.png" width="425" />
</div>

<p>Again, worse results.</p>

<h2 id="comparison-to-gibbs">Comparison to Gibbs</h2>

<p>Lile we did for Gibbs, we run 10 times this MCMCMHU model. Now with mixing time of 5,000 and sample size of 30,000. Starting assignment, 5 runs with 0s, and 5 runs with 1s. We compute the error as before and see what results we get as compared to the exact marginals for all variables.</p>

<p>The error, as defined in previous posts, from our 10 runs is 0.12 on the average (vs. 0.065 from Gibbs), with a range of [0.03, 0.24] (vs. [0.005, 0.17]) and a standard deviation of 0.07 (vs. 0.05). Definetively worse performance.</p>

<p>Finally, this is for a 9 node Ising net. For a 4 sided net with 16 nodes, with strong correlation this MHU method performs very poorly because we get stuck in specific assignments for very long times. Because the probability of a new assignment (randomly chosen) tends to be so small as compared to the probability we start with that the ratio is miniscule, and A() always rejects. The more correlated (i.e. higher on diagonal values vs off diagonal) the more steps we need to take, and even that doesn’t guarantee good results. Consider that for 100,000 steps, only around 50 are accepted, which means we need to run it much longer to achieve good results. </p>

<p>For the easiest 16 nodes with pairwise potentials [0.5, 0.5], 0 mixing and 30,000 steps, MHU and Gibs give similar good results. MHU gives us an average error and standard dev of [0.02, 0.004], while Gibbs achieves [0.01, 0.001].</p>

<div>
    <img class="left" src="/images/feb14/Gibbs_hist.png" width="425" title="Gibbs Error 100 Runs" />
    <img class="right" src="/images/feb14/MHU_hist.png" width="425" title="MHU Error 100 Runs" />
</div>
<p><br /></p>

<p>Finally we compare the histogram of errors for these two methods when applied to the [1.0, 0.2] in the 16 node Ising model. Each histogram is based on 100 runs. Both have a mixing time of 10,000 and a sampling size of 70,000. Gibbs’s histogram shown in red, MHU in blue.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/02/12/MCMC-MH-Theory/">MCMC ~ Metropolis Hastings</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-02-12T08:01:00-08:00" pubdate data-updated="true">Feb 12<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>With Gibbs sampling, we changed the assigment of our variables one at a time, and after cycling though all the variables we got to new state, a complete new assignment to all variables. </p>

<p>For regular chains, Gibbs sampling is a legal MCMC transition, meaning that it results in a Markov Chain with the right stationary distribution. But with high autocorrelations between variables, trying to change the value of one variable at a time tends to leave us in the same state or the same cluster of similar states, because the one variable we change at a time remains strongly constrained by its neighbors. So mixing is slow. </p>

<p>We’d like to use a transition that lets us make bigger moves around the state space, but we still have to make sure our transition is a legal MCMC. The Metropolis-Hastings algorithm tries to do this. We choose the transition we actually want – one that takes large steps around the state space. Then we modify that transition, using an acceptance probability, that forces it into a legal MCMC transition. </p>

<h2 id="q-and-a">Q and A</h2>

<p>Our MCMC transition then has two steps. First we choose a proposed new state (x’), using our transition probabilities Q(x → x’). Then we accept that new state, with probability A(x → x’). If the transition is accepted, our new assignment is the proposed new state, but if the transition is rejected, our new assignment is the same as the old one.</p>

<p>For a given proposal transition Q(x → x’), the acceptance probability is given by: </p>

<script type="math/tex; mode=display">
\begin{align}

A(x \rightarrow x') = min \left[ 1, \frac{\pi(x') Q(x' \rightarrow x)}{\pi(x) Q(x \rightarrow x')} \right]

\end{align}
</script>

<p>The key is that A is determined once we know Q, so the art is in finding the right Q. One that:</p>

<ul>
  <li>
    <p>is reversible, so if there is a positive probability of getting from x to x’, then the probability of getting from x’ to x is also positive.</p>
  </li>
  <li>
    <p>allows us to go far away places, but without getting so far away that the probability of acceptances becomes too low, because then we won’t move at all.</p>
  </li>
</ul>

<p>Finding Q is hard, and an art that depends of the PGM at hand. Also, a legal Q is such that for every two states/assignments (x, x’), the probability of transitioning (x → x’) is exactly the same as the probability of transitioning in reverse (x’ → x), [such property is called ‘detailed balance’]. </p>

<h2 id="q-as-gibbs-or-gibbs-as-mh">Q as Gibbs, or Gibbs as MH</h2>

<p>We can insert Gibbs into our MH framework with a trick. We consider that the Gibbs sampling method is our Q(x → x’), our way of finding new assignment (even if in litle steps which violates the MH goal, but it is a trick). Since Gibbs is already legal, all we need is to define an approval distribution A(x → x’) that always accepts whatever Q (Gibbs) brings, for example A(x → x’) = 1.</p>

<h2 id="q-as-the-uniform-distribution">Q as the Uniform distribution</h2>

<p>A very simple Q is based on the Uniform distribution. For all the variables in the assignment we randomly choose (independently) new assignments. Brutishly. All at once. Then we compute the transitions by multiplying the specific probabilities of getting that evidence (to and from the initial assignment from/to the new assignment). Now we can compute the acceptance probability A.</p>

<p>The problem is that because we are pulling out assignments out of a hat randomly, most of them will be very unique/unrelated and therefore with low-probability transition. A low probability transition will surely get rejected by the acceptance step, and so we end up lingering in one state rather than exploring the state space. So we may end up with tons of failed trials, tons of staying put, and we only move out of the assignment when we don’t go too far.</p>

<p>Ising models and image segmentation applications tend to rely on pairwise Markov networks. In these networks, adjacent variables tend to take on the same values. This makes it hard to explore the space for proposal distributions which change the value of one variable at a time, such as Gibbs or the uniform proposal distribution.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/8/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/6/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/04/Seattlerb-GoL/">Seattle Ruby Game Of Life</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/01/CodeFellows/">Article Published</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/15/Scheme-GOL/">Game of Life in Scheme</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/18/4-PSD/">4 Principles of Simple Design Reflections</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/17/Code-Retreat/">Code Retreat Reflections</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 -  Javier Soto <br/>
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> + <a href="https://github.com/ioveracker/mnml">mnml</a>.
	  
  </span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'sotoseattle';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
