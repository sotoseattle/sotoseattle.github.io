<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JS, | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2014-10-23T18:21:46-07:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript OO Review]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/20/JS-review/"/>
    <updated>2014-10-20T14:30:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/20/JS-review</id>
    <content type="html"><![CDATA[<p>Interestingly enough JS is class-less yet everything is an object. There are 3 ways to instantiate an object:</p>

<p><code>javascript
var newObject = {};
var newObject = Object.create( Object.prototype );
var newObject = new Object();
</code></p>

<h3 id="the-literal-object-pattern">The Literal Object Pattern</h3>
<p>The first one is the object literal, a self contained wrapped object with all properties held inside in key / value pairs separated by commas. Check this <a href="http://rmurphey.com/blog/2009/10/15/using-objects-to-organize-your-code/">article</a>. It is a very neat to create objects in JS, clean and encapsulated that keep the code simple and clean.</p>

<p>The last one uses the Object constructor, something similar to Ruby’s BasicObject class.</p>

<h3 id="the-constructor-pattern">The Constructor Pattern</h3>
<p>Constructors are special functions. Or seen another way, by prefixing the word <code>new</code> to a function we tell JS to instantiate an Object according to the specifications defined in the function.</p>

<p>```javascript
function Car(model) {
  this.model = model;
  this.to_s = function() { return “model: “ + this.mode; }
}</p>

<p>var model_T = new Car(‘Ford T’);
```</p>

<p>In this manner we can define what in ruby are instance variables and methods, but here they all are properties in key value pairs, independently of them being other object or functions.</p>

<p>The main problem is that we are defining the ‘methods’ inside each object at instantiation time. In Ruby the behavior is held in the Class, a common repo for all instantiated objects derived from it.</p>

<p>Enter the prototype, another object that is common to all JS objects. When we create an object with a constructor, everything defined in the constructor’s function is available to all instances created from it, analogous to a ruby class in terms of a common repo where all objects can go to find the methods they have.</p>

<p><code>javascript
Car.prototype.to_s = function() { return "model: " + this.mode; }
</code></p>

<h3 id="the-module-pattern">The Module Pattern</h3>

<p>The idea behind it is to encapsulate and it resembles OO practices.</p>

<p><blockquote><p>Variables can’t technically be declared as being public nor private and so we use function scope to simulate this concept. Within the Module pattern, variables or methods declared are only available inside the module itself thanks to closure.</p><footer><strong>Addy Osmani, Learning JavaScript Design Patterns</strong> <cite><a href='http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript'>addyosmani.com/resources/book/&hellip;</a></cite></footer></blockquote></p>

<p>A module template that touches on private and public variables would like the following:</p>

<p>```javascript
var myNamespace = (function () {</p>

<p>var myPrivateVar, myPrivateMethod;</p>

<p>// A private counter variable
  myPrivateVar = 0;</p>

<p>// A private function which logs any arguments
  myPrivateMethod = function( foo ) {
      console.log( foo );
  };</p>

<p>return {</p>

<pre><code>// A public variable
myPublicVar: "foo",

// A public function utilizing privates
myPublicFunction: function( bar ) {

  // Increment our private counter
  myPrivateVar++;

  // Call our private method using bar
  myPrivateMethod( bar );

}   }; })(); ```
</code></pre>

<p>Inside the module we have some internal private stuff shielded from the outside, and the module returns an object with the public API and public variables. This returned object is assigned to the myNamespace variable so we access its innards as properties of the object.</p>

]]></content>
  </entry>
  
</feed>
