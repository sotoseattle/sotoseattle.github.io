<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby, | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2014-10-23T17:46:42-07:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Metaprogramming in Action]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/05/Metaprogramming/"/>
    <updated>2014-10-05T08:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/05/Metaprogramming</id>
    <content type="html"><![CDATA[<p>The <a href="github.com/dkubb/equalizer">Equalizer gem</a> provides a nifty example of Ruby metaprogramming.</p>

<p>It is a module that when added to your class helps define equality, equivalence and inspection methods.</p>

<p>```ruby
class GeoLocation
  include Equalizer.new(:latitude, :longitude)</p>

<p>attr_reader :latitude, :longitude</p>

<p>def initialize(latitude, longitude)
    @latitude, @longitude = latitude, longitude
  end
end</p>

<p>point_a = GeoLocation.new(1, 2)
point_b = GeoLocation.new(1, 2)</p>

<p>point_a.inspect    # =&gt; “#&lt;GeoLocation latitude=1 longitude=2&gt;”</p>

<p>point_a == point_b           # =&gt; true
point_a.hash == point_b.hash # =&gt; true
```</p>

<h2 id="include-instance-of-a-module">Include instance of a Module?</h2>

<p><code>ruby
# example
class GeoLocation
  include Equalizer.new(:latitude, :longitude)
...
</code></p>

<p>The first thing that kicks your gut when reading the code is the instantiation of the module. What? Weren’t modules used to be abstract, nice little packages of functionality, classes devoid of the perils and tribulations born out of fleshed-out Objects?</p>

<p>In Ruby everything is an Object, as we wouldn’t deny the right to be objectified to anybody, so the following two ways of coding a module are equivalent:</p>

<p>```ruby
module Insane
  def hello
    ‘hola’
  end
end</p>

<p>Insane = Module.new do
  def hello
    ‘hola’
  end
end
```</p>

<p>Now that we see that everything is an object we inspect Equalizer’s code:</p>

<p>```ruby
# equalizer.rb
class Equalizer &lt; Module
  def initialize(*keys)
    @keys = keys
    define_methods
    freeze
  end
  …
end</p>

<h1 id="example">example</h1>
<p>class GeoLocation
  include Equalizer.new(:latitude, :longitude)
…
```</p>

<p>Aha! It passes certain attributes of the GeoLocation class (passed as keys: latitute and longitude) to make them comparable. For this we need to customize the methods inside the module (because different objects will have different attributes, and we want something reusable).</p>

<p>And there lies the rub, the double nature of Equalizer.</p>

<ol>
  <li>Equalizer is a Module and by ‘including’ it, GeoLocation makes all methods from Equalizer available to his objects.</li>
  <li>Yet Equalizer is defined as a class that can be instantiated.</li>
</ol>

<p>But we have seen that everything is an object, so the instantiation must serve a different purpose.</p>

<p>Yes, by defining Equalizer as a class that can be instantiated, at that moment of instantiation we can pass the specific instance variables to customize those methods (the ‘keys’). So Equalizer defines methods based on something undefined (keys), and only at inclusion (when we know which are the instance variables to make comparable) it customizes its module’s methods on the fly.</p>

<p>Although a stateless, Equalizer is able to be adapt to the circumstances of each class that will include it. In our example, at instantiation it uses GeoLocation’s latitude and longitude to redefine its methods at the last minute, to the effect of adding to them the ability to be comparable.</p>

<h2 id="define-method">Define Method</h2>

<p>Among other metaprogramming tricks it uses the define_method extensively. Although this is usually done to create a new named method at runtime, in this case, the method’s names are set from the start, what is created dynamically is the way the method operates.</p>

<p>For example, the cmp? (comparable?) method has a set name (cmp?) and the blocks passed is also well defined (we check that all keys of both objects return the same values), but the fact that we won’t know which keys are available to compare until runtime makes this use an example of metaprogramming.</p>

<p>```ruby
# where we make attributes comparable
def define_cmp_method
  keys = @keys
  define_method(:cmp?) do |comparator, other|
    keys.all? { |key| send(key).send(comparator, other.send(key)) }
  end
  private :cmp?
end</p>

<h1 id="the-comparisson-method">The comparisson method</h1>
<p>def ==(other)
  other = coerce(other) if respond_to?(:coerce, true)
  other.is_a?(self.class) &amp;&amp; cmp?(<strong>method</strong>, other)
end
```</p>

<p>Two notes:</p>

<ol>
  <li>
    <p>The cmp? method is just a DRY method used to define the real comparison methods (eql? and ==). This way it is easy to extend.</p>
  </li>
  <li>
    <p>Consider also that we include this Equalizer class as an instantiated object when defining the class, so when we instantiate a new object all Equalizer methods are available as instance methods already defined for the existing instance variables.</p>
  </li>
</ol>
]]></content>
  </entry>
  
</feed>
