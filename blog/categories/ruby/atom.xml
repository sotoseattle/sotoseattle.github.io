<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2015-01-07T08:11:00-08:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[4 Principles of Simple Design Reflections]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/11/18/4-PSD/"/>
    <updated>2014-11-18T10:17:00-08:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/11/18/4-PSD</id>
    <content type="html"><![CDATA[<p>Following my previous post I have been thinking about the 4 Principles of Simple Design, their meaning and their applications to the little coding exercise of the Game of Life. These principles are:</p>

<ol>
  <li>Code pases tests =&gt; test drive development</li>
  <li>Code reveals intent =&gt; can be read and understood, expressive</li>
  <li>DRY =&gt; more in terms of knowledge than code</li>
  <li>Code is simple, minimal =&gt; the least code to do/express the most</li>
</ol>

<p>I really like the idea of priorities, of never violating higher level principles. So if you can compress a complex method into a single clever line, you don’t do it if it becomes less readable, if it becomes confusing and difficult to understand. So first and foremost, pass the tests, make sure the code does what is supposed to do, that it adds value. Then make it accessible, etc. And find compromises among the principles never losing sight of where the priorities stand.</p>

<p>A big lesson learned is not to be afraid of throwing away code. You lose semi-working code, but you gain insight about the problem and the code. In the end, the balance is positive. The code is better.</p>

<p>I find it impressive that if you follow the path, the result is really clean, simple and expressive code.</p>

<p>I find it interesting that if you follow the path, your code may already solve many of the subsequent challenges of Code Retreats. Things like:</p>

<ul>
  <li>small methods</li>
  <li>no conditionals</li>
  <li>no naked data structures</li>
  <li>no primitive classes</li>
</ul>

<p>Here are the main classes of my Game of Life so far:
<!--more--></p>

<p>```ruby
class GOL
  attr_reader :world</p>

<p>def initialize
    @world = World.new
  end</p>

<p>def add(another_living_cell_location)
    @world.add(another_living_cell_location)
  end</p>

<p>def remove(living_cell_location)
    @world.delete(living_cell_location)
  end</p>

<p>def tick
    will_die   = @world.unsustainable_locations
    will_spawn = @world.germinal_locations
    tock(will_die, will_spawn)
  end</p>

<p>private</p>

<p>def tock(dead_cells, born_cells)
    dead_cells.each { |cell| remove(cell) }
    born_cells.each { |cell| add(cell) }
  end
end</p>

<p>class World &lt; Set
  alias_method :number_of_living_cells, :size</p>

<p>def unsustainable_locations
    select { |loc| !survives?(loc) }
  end</p>

<p>def germinal_locations
    potential_perimeter.select { |loc| fertile?(loc) }
  end</p>

<p>private</p>

<p>def potential_perimeter
    possible_locations = Set.new
    each { |loc| possible_locations |= loc.adjacents }
    possible_locations.subtract self
  end</p>

<p>def fertile?(location)
    alive_nearby(location) == 3
  end</p>

<p>def survives?(location)
    alive_nearby(location).between?(2, 3)
  end</p>

<p>def alive_nearby(location)
    location.adjacents.count { |loc| include?(loc) }
  end
end</p>

<p>Location = Struct.new(:x, :y) do
  def adjacents
    perimeter_coordinates.map { |coords| Location.new(*coords) }
  end</p>

<p>protected</p>

<p>def perimeter_coordinates
    [x + 1, x, x - 1].product([y - 1, y, y + 1]) - [[x, y]]
  end</p>

<p>def hash
    to_a.hash
  end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Retreat Reflections]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/11/17/Code-Retreat/"/>
    <updated>2014-11-17T20:17:00-08:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/11/17/Code-Retreat</id>
    <content type="html"><![CDATA[<p>Last Saturday 15, Nov I participated in the Global day of Code Retreat 2014. Although I could only join for half a day, it was an intense learning experience.</p>

<p>One of the goals of the exercise is to get one out of his coding comfort-zone. Like thrown into a dark room we stretch the arms to ‘feel’ and ‘see’ what is next, when I was taken out of my way of thinking, when confronted with a curve ball to code (zombie cells?) or when I had to pair in a different language, I was forced to stretch my arms and use short bursts of tests as the only way to gain ground and advance.</p>

<p><img class="left" src="/images/Nov14/Game_of_life_pulsar.gif" width="200">
“Game of life pulsar” by JokeySmurf <a href="http://commons.wikimedia.org/wiki/File:Game_of_life_pulsar.gif#mediaviewer/File:Game_of_life_pulsar.gif">Licensed under Public domain via Wikimedia Commons</a></p>

<p>The pair experience was happily horrifying, God I need to work on that! Adding ping-pong style to it, raised the stakes to the level of Hunger Games.</p>

<p>Nevertheless, I spent the next day working on the Game of Life, trying to code it from the point of view of the 4 Principles of Simple Design and thinking about the process.</p>

<p>My unfinished code is <a href="https://github.com/sotoseattle/CodeRetreat">here</a> and these notes are my reflections on the process.</p>

<h3 id="learning-to-fly">Learning to Fly</h3>

<p>First and foremost I not only started every iteration writing the tests, but tried to write them from the most general point of view, avoiding referring to implementation details. This is extremely difficult for two reasons:</p>

<p>First, unconsciously, when I pose a testing question / requirement I already have an implicit idea of how to answer it. Visualizing how things should work, even if only in the end point (as seen by customer or objects), does not happen in a vacuum. As soon as one starts to think about it, the mind starts to consider alternatives: data structures, algorithms, etc, from past experience. Furthermore, when you write the details of the test you are specifying the objects to use and the methods to call.</p>

<p>I want to keep the questions as open-ended as possible, so later on the code can answer as it sees fit, from the trenches in the battlefield and not directed by an armchair admiral.</p>

<p>Second, if the test is too general, too abstract, too high altitude, it ends up encompassing way too much functionality, which requires to implement too many things in too many places in order to pass the test. Therefore I need to get down from the high chair and make more concrete, low level requirements. But this in turn, (i.e. calling a specific intermediary method in my test) is already steering and making me think of concrete implementation details!</p>

<p>There is great tension between these forces, between flying high without getting lost in space, and flying low and hitting the rooftops.
<!--more-->
### Gravity Pull</p>

<p>Another difficulty I have experienced. By passing tests and only passing them, without regard for the overall design from the get go, I tend to find myself thinking in a tunnel, with a narrow scope of the problem (pass the test). Like doing white-board challenges, way too close to what I am writing in the white-board, unable to see and play with the whole picture.</p>

<p>This narrowing is like a gravitational pull. Happens without being aware. The way to fight it was through the refactoring phase. Then I could step back, or fly to a higher altitude and look at the code in its entirety, check how the pieces work together, and try to give them a more consistent and natural feel.</p>

<h3 id="writing-test-miss-conception">Writing Test Miss-conception</h3>

<p>Initially I though that the tests were going to be written in stone, once written they would remain essentially the same (not considering small refactorings to input/output as we add features). I was wrong. I have found myself refactoring tests as much as code. What I though should belong to Cell ended up in a Location object, and that forced the test itself to change. Tests were written, deleted, moved, and refactored continuously. Tests became Code.</p>

<h3 id="advance-retreat-pivot-repeat-somersault-wtf">Advance, Retreat, Pivot, Repeat, Somersault, WTF</h3>

<p>Imagine the situation: you have a test to pass so you start coding to find out that you are going to need some intermediate methods. What do you do, retreat and write test for these intermediate methods? Or plunge ahead and implement them to pass the original? Which means you will need to write tests for that interim method a posteriori? I have found that the process is not clear cut or linear, and that you need to keep a loose attitude about it, making compromises, keeping the writing of your test and methods in fluid motion.</p>

<p>The same happens if, in the middle of the process, you want to explore a line of thought. You may want to play in the sandbox and not write a test a priori about something that may not be used or whose utility is more about writing an idea into code so a better one emerges or it clarifies a whole concept.</p>

<h3 id="emergence">Emergence</h3>

<p>One of the main things I wanted to evaluate in the first place was the ability of the process to allow good code to emerge naturally.</p>

<p>I started only considering living cells that live and die because of the proximity of other cells. The key being that I did not consider locations where new cells would emerge, that feature was left for later.</p>

<p>Through the iterative process I ended up differentiating between Location and Cell, so the cell attends only to its biological imperatives and the location encapsulates all the geographical functionality (coordinates). This allowed me to have a minimal controller of the game that only kept track of living cells. Later on I added a new class, a Chart, to visualize a group of locations (of the living cells).</p>

<p>Now, for the fun part. Given this code at this stage, the result of the aforementioned process. Where I have taken good care of keeping things encapsulated, apart, to each according to his responsibilities and capabilities. How hard would it be to add the functionality of certain locations becoming populated by new cells due to proximity of other living cells?</p>

<h3 id="close-but-no-cigar">Close, but no cigar!</h3>

<p>Well, no. It didn’t save me the pain of a big refactoring.</p>

<p>Once I had to consider spawning locations the whole design fell to pieces. I was tracking living cells and the Cell class had responsibility over knowing its neighbors. Now that I needed to find a way to encompass both, tracking already living cells and looking for fertile locations where new cells could come to life, I saw that keeping track of and analyzing locations could achieve both things in a single stroke.</p>

<p>I could see 3 ways to go about it:</p>

<ol>
  <li>Topologically, considering only locations, like a potential field.</li>
  <li>Biologically, with a graph made of cells, which I traverse to decide if I create new ones in neighboring spaces.</li>
  <li>Topo for spawning locations and bio for living cells. May make the most natural sense, since spawning locations and living cells are different things, but I cannot see it being worth the extra level of complexity. A more complex setting could make me choose this route.</li>
</ol>

<p>On one hand, this high level understanding of the design could have been taken head-on from the start, saving me the extra miles walked down the cell path, to only retrace and re-code it as location based.</p>

<p>On the other hand, this process allowed me to never get stuck because of the complexity of the problem. I was always able to advance, even if it meant taking 2 steps forward and one back. If time is not a constraint this way feels natural and it flows.</p>

<p>Another benefit was that I could always relay on the test previously written. This is an immense aid and a boost to the confidence that the new route (big refactoring) works.</p>

<p>A final benefit is that the continuous refactoring ends up making the whole language more natural, the code minimized code and me having a deeper understanding of how everything works. The fact that I was building and breaking things continuously forced me to be always make things as clear and small as possible, so I wouldn’t get lost with all the commotion.</p>

<h3 id="disclaimer">Disclaimer</h3>

<p>The code was left unfinished. The GOL class should have a method ‘play’, a way to set the initial state of living cells from a text file (for example), and a way to visualize the evolution of the game in a fixed referenced window. The chart class itself, which visualizes the board, is messy and would benefit from refactoring.</p>

<p>Absolutely more tests are needed. I still need to work on really covering all possible scenarios for each class. I started strong but I have the feeling that I dropped the ball a bit by the end.</p>
]]></content>
  </entry>
  
</feed>
