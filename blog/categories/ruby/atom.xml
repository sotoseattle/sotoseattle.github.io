<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2015-12-05T13:58:37-08:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Continuations]]></title>
    <link href="http://sotoseattle.github.io/blog/2015/12/05/ruby-continuations/"/>
    <updated>2015-12-05T12:14:40-08:00</updated>
    <id>http://sotoseattle.github.io/blog/2015/12/05/ruby-continuations</id>
    <content type="html"><![CDATA[<p>Continuations are a useful device for many coding tasks. I like to visualize them as portals or wormholes that connect different parts of your code. Continuations allow you to hyper-jump from one place of your executing code to another without missing a bit. The following is an example of how they can be used:</p>

<p><img class="center" src="/images/dec15/portal.jpg" width="800">
<!--more--></p>

<blockquote>
  <p>Given a binary tree and two nodes A and B from within that tree, write a function to find the node which is the first common ancestor of A and B.</p>
</blockquote>

<p>You already know how to search binary trees, depth or breadth first, and you could just traverse the tree in search of the nodes and pick up the parents as you go along. That is not intrinsically difficult and there are many examples on the Internet. The problem is that you need to run through the whole tree every time you initiate a search. Could there be a way to stop moving along the tree once you find the node and simple return to sender? Yes, one way is with continuations.</p>

<p><img class="right" src="/images/dec15/treesearch.png" width="300"></p>

<p>Intuitively what we want is something similar to the following:</p>

<ul>
  <li>We open a portal at the start of our journey, at the root or beginning of the tree. This portal is where we want to go back to when we find the node. It is our way to get back home as we get lost in the multiverse of recurring calls through the tree.</li>
  <li>Once we secure a way back, we jump in the rabbit hole, we start searching the tree, going from node to node, a dazzling pin-ball.</li>
  <li>As we go along, as we search for The Node, we keep a bread crumb track of the path taken.</li>
  <li>After many jumps between nodes, already disoriented, we arrive to The Node we were after. But, alas! our tree is made of nodes that do not link upwards to parents, only downwards to children, so we cannot use our bread crumbs to dig ourselves back to the root!</li>
  <li>Yet we know that we have an opened portal at the root. And as we all know from Cosmology 101 we can always open the other end of the wormhole with our sonic screwdriver and get back to safety.</li>
</ul>

<p>The final code would look like the following. I leave up to you to make sense of the details (the Internet is full of better explanations than this one :-).</p>

<p>```ruby
module Ancestry
  require ‘continuation’</p>

<p>def ancestors node
    portal = callcc {|cont| cont}                   # open cosmological-portal (brrrrzzzzzuinga!!)</p>

<pre><code>return portal unless portal.is_a? Continuation  # return whatever was sent through the portal

find node, [], portal                           # go down the rabbit hole in search of node   end
</code></pre>

<p>def find n, crumbtrail, getaway
    getaway.call crumbtrail if self == n            # if found, send ancestry logbook through the portal</p>

<pre><code>(@left  &amp;&amp; @left.find( n, crumbtrail + [self], getaway)) ||
(@right &amp;&amp; @right.find(n, crumbtrail + [self], getaway))   end
</code></pre>

<p>def common_ancestor a, b
    (ancestors(a) &amp; ancestors(b)).last
  end
end</p>

<p>class Bintree
  include Ancestry
  attr_accessor :val, :left, :right</p>

<p>def initialize val
    @left = @right = nil
    @val = val
  end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seattle Ruby Game Of Life]]></title>
    <link href="http://sotoseattle.github.io/blog/2015/03/04/Seattlerb-GoL/"/>
    <updated>2015-03-04T10:00:00-08:00</updated>
    <id>http://sotoseattle.github.io/blog/2015/03/04/Seattlerb-GoL</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/mar15/wheel.png" width="250"></p>

<p>Last Tuesday the Seattle Ruby group organized a workshop to code Conway’s Game of Life. It was a first (at least in a long time), and I think it was a success. People were engaged and everybody was focused coding away in the 45 minutes we had. We even had a Wheel of Misfortune so people could add randomized constraints in case the problem was too easy.</p>

<p>A repository was published prior to the event so people could familiarized themselves with the problem. <a href="https://github.com/SeaRbSg/workshops">Repo</a>. The following are some examples included in the common repo from some contributors:</p>

<p>Lito Nicolai had an amazing implementation using matrices:</p>

<!--more-->

<p><br /></p>

<p>```ruby
require ‘matrix’
require ‘./matrix_math’</p>

<p>def sum l
  l.reduce :+
end</p>

<p>def twos grid
  grid.map{|i| if i == 2 then 1 else 0 end}
end</p>

<p>def threes grid
  grid.map{|i| if i == 3 then 1 else 0 end}
end</p>

<p>def neighbors grid
  sum( [-1, 0, 1].product([-1, 0, 1]).map{|x, y| grid.rotate x, y } ) - grid
end</p>

<p>def life grid
  ((twos neighbors grid) &amp; grid) | (threes neighbors grid)
end
```</p>

<p>For my part, the most simple code I could come up with was a purely functional implementation:</p>

<p>```ruby
module GOL
  def tick(living)
    potential = living.map { |c| neighbors(c) }.flatten(1).uniq - living</p>

<pre><code>new_board = living.select { |cell| alive_around(cell, living).between?(2, 3) }
new_board += potential.select { |cell| alive_around(cell, living) == 3 }

return new_board   end
</code></pre>

<p>def neighbors(cell)
    x, y = cell
    [x + 1, x, x - 1].product([y - 1, y, y + 1]) - [[x, y]]
  end</p>

<p>def alive_around(cell, board)
    neighbors(cell).count { |c| board.include? c }
  end
end
```</p>

<p>Ryan Davis not only contributed with code but with a visualization library based on GOSU. See it in action as it helps visualize the code of two different approaches written by Ryan and Scott Windsor.</p>

<p><br /></p>

<p><img class="left" src="/images/mar15/zen_gol.gif" width="420">
<img class="right" src="/images/mar15/sentientmonkey_gol.gif" width="420"></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Article Published]]></title>
    <link href="http://sotoseattle.github.io/blog/2015/03/01/CodeFellows/"/>
    <updated>2015-03-01T10:00:00-08:00</updated>
    <id>http://sotoseattle.github.io/blog/2015/03/01/CodeFellows</id>
    <content type="html"><![CDATA[<p>Just a brief note to announce that Code Fellows has published a guest post I wrote.</p>

<p>Enjoy the amazing wisdom it distills at: <a href="https://www.codefellows.org/blog/learning-rails-5-tips-to-become-an-exceptional-rails-developer">Article</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4 Principles of Simple Design Reflections]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/11/18/4-PSD/"/>
    <updated>2014-11-18T10:17:00-08:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/11/18/4-PSD</id>
    <content type="html"><![CDATA[<p>Following my previous post I have been thinking about the 4 Principles of Simple Design, their meaning and their applications to the little coding exercise of the Game of Life. These principles are:</p>

<ol>
  <li>Code pases tests =&gt; test drive development</li>
  <li>Code reveals intent =&gt; can be read and understood, expressive</li>
  <li>DRY =&gt; more in terms of knowledge than code</li>
  <li>Code is simple, minimal =&gt; the least code to do/express the most</li>
</ol>

<p>I really like the idea of priorities, of never violating higher level principles. So if you can compress a complex method into a single clever line, you don’t do it if it becomes less readable, if it becomes confusing and difficult to understand. So first and foremost, pass the tests, make sure the code does what is supposed to do, that it adds value. Then make it accessible, etc. And find compromises among the principles never losing sight of where the priorities stand.</p>

<p>A big lesson learned is not to be afraid of throwing away code. You lose semi-working code, but you gain insight about the problem and the code. In the end, the balance is positive. The code is better.</p>

<p>I find it impressive that if you follow the path, the result is really clean, simple and expressive code.</p>

<p>I find it interesting that if you follow the path, your code may already solve many of the subsequent challenges of Code Retreats. Things like:</p>

<ul>
  <li>small methods</li>
  <li>no conditionals</li>
  <li>no naked data structures</li>
  <li>no primitive classes</li>
</ul>

<p>Here are the main classes of my Game of Life so far:
<!--more--></p>

<p>```ruby
class GOL
  attr_reader :world</p>

<p>def initialize
    @world = World.new
  end</p>

<p>def add(another_living_cell_location)
    @world.add(another_living_cell_location)
  end</p>

<p>def remove(living_cell_location)
    @world.delete(living_cell_location)
  end</p>

<p>def tick
    will_die   = @world.unsustainable_locations
    will_spawn = @world.germinal_locations
    tock(will_die, will_spawn)
  end</p>

<p>private</p>

<p>def tock(dead_cells, born_cells)
    dead_cells.each { |cell| remove(cell) }
    born_cells.each { |cell| add(cell) }
  end
end</p>

<p>class World &lt; Set
  alias_method :number_of_living_cells, :size</p>

<p>def unsustainable_locations
    select { |loc| !survives?(loc) }
  end</p>

<p>def germinal_locations
    potential_perimeter.select { |loc| fertile?(loc) }
  end</p>

<p>private</p>

<p>def potential_perimeter
    possible_locations = Set.new
    each { |loc| possible_locations |= loc.adjacents }
    possible_locations.subtract self
  end</p>

<p>def fertile?(location)
    alive_nearby(location) == 3
  end</p>

<p>def survives?(location)
    alive_nearby(location).between?(2, 3)
  end</p>

<p>def alive_nearby(location)
    location.adjacents.count { |loc| include?(loc) }
  end
end</p>

<p>Location = Struct.new(:x, :y) do
  def adjacents
    perimeter_coordinates.map { |coords| Location.new(*coords) }
  end</p>

<p>protected</p>

<p>def perimeter_coordinates
    [x + 1, x, x - 1].product([y - 1, y, y + 1]) - [[x, y]]
  end</p>

<p>def hash
    to_a.hash
  end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Retreat Reflections]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/11/17/Code-Retreat/"/>
    <updated>2014-11-17T20:17:00-08:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/11/17/Code-Retreat</id>
    <content type="html"><![CDATA[<p>Last Saturday 15, Nov I participated in the Global day of Code Retreat 2014. Although I could only join for half a day, it was an intense learning experience.</p>

<p>One of the goals of the exercise is to get one out of his coding comfort-zone. Like thrown into a dark room we stretch the arms to ‘feel’ and ‘see’ what is next, when I was taken out of my way of thinking, when confronted with a curve ball to code (zombie cells?) or when I had to pair in a different language, I was forced to stretch my arms and use short bursts of tests as the only way to gain ground and advance.</p>

<p><img class="left" src="/images/Nov14/Game_of_life_pulsar.gif" width="200">
“Game of life pulsar” by JokeySmurf <a href="http://commons.wikimedia.org/wiki/File:Game_of_life_pulsar.gif#mediaviewer/File:Game_of_life_pulsar.gif">Licensed under Public domain via Wikimedia Commons</a></p>

<p>The pair experience was happily horrifying, God I need to work on that! Adding ping-pong style to it, raised the stakes to the level of Hunger Games.</p>

<p>Nevertheless, I spent the next day working on the Game of Life, trying to code it from the point of view of the 4 Principles of Simple Design and thinking about the process.</p>

<p>My unfinished code is <a href="https://github.com/sotoseattle/CodeRetreat">here</a> and these notes are my reflections on the process.</p>

<h3 id="learning-to-fly">Learning to Fly</h3>

<p>First and foremost I not only started every iteration writing the tests, but tried to write them from the most general point of view, avoiding referring to implementation details. This is extremely difficult for two reasons:</p>

<p>First, unconsciously, when I pose a testing question / requirement I already have an implicit idea of how to answer it. Visualizing how things should work, even if only in the end point (as seen by customer or objects), does not happen in a vacuum. As soon as one starts to think about it, the mind starts to consider alternatives: data structures, algorithms, etc, from past experience. Furthermore, when you write the details of the test you are specifying the objects to use and the methods to call.</p>

<p>I want to keep the questions as open-ended as possible, so later on the code can answer as it sees fit, from the trenches in the battlefield and not directed by an armchair admiral.</p>

<p>Second, if the test is too general, too abstract, too high altitude, it ends up encompassing way too much functionality, which requires to implement too many things in too many places in order to pass the test. Therefore I need to get down from the high chair and make more concrete, low level requirements. But this in turn, (i.e. calling a specific intermediary method in my test) is already steering and making me think of concrete implementation details!</p>

<p>There is great tension between these forces, between flying high without getting lost in space, and flying low and hitting the rooftops.
<!--more-->
### Gravity Pull</p>

<p>Another difficulty I have experienced. By passing tests and only passing them, without regard for the overall design from the get go, I tend to find myself thinking in a tunnel, with a narrow scope of the problem (pass the test). Like doing white-board challenges, way too close to what I am writing in the white-board, unable to see and play with the whole picture.</p>

<p>This narrowing is like a gravitational pull. Happens without being aware. The way to fight it was through the refactoring phase. Then I could step back, or fly to a higher altitude and look at the code in its entirety, check how the pieces work together, and try to give them a more consistent and natural feel.</p>

<h3 id="writing-test-miss-conception">Writing Test Miss-conception</h3>

<p>Initially I though that the tests were going to be written in stone, once written they would remain essentially the same (not considering small refactorings to input/output as we add features). I was wrong. I have found myself refactoring tests as much as code. What I though should belong to Cell ended up in a Location object, and that forced the test itself to change. Tests were written, deleted, moved, and refactored continuously. Tests became Code.</p>

<h3 id="advance-retreat-pivot-repeat-somersault-wtf">Advance, Retreat, Pivot, Repeat, Somersault, WTF</h3>

<p>Imagine the situation: you have a test to pass so you start coding to find out that you are going to need some intermediate methods. What do you do, retreat and write test for these intermediate methods? Or plunge ahead and implement them to pass the original? Which means you will need to write tests for that interim method a posteriori? I have found that the process is not clear cut or linear, and that you need to keep a loose attitude about it, making compromises, keeping the writing of your test and methods in fluid motion.</p>

<p>The same happens if, in the middle of the process, you want to explore a line of thought. You may want to play in the sandbox and not write a test a priori about something that may not be used or whose utility is more about writing an idea into code so a better one emerges or it clarifies a whole concept.</p>

<h3 id="emergence">Emergence</h3>

<p>One of the main things I wanted to evaluate in the first place was the ability of the process to allow good code to emerge naturally.</p>

<p>I started only considering living cells that live and die because of the proximity of other cells. The key being that I did not consider locations where new cells would emerge, that feature was left for later.</p>

<p>Through the iterative process I ended up differentiating between Location and Cell, so the cell attends only to its biological imperatives and the location encapsulates all the geographical functionality (coordinates). This allowed me to have a minimal controller of the game that only kept track of living cells. Later on I added a new class, a Chart, to visualize a group of locations (of the living cells).</p>

<p>Now, for the fun part. Given this code at this stage, the result of the aforementioned process. Where I have taken good care of keeping things encapsulated, apart, to each according to his responsibilities and capabilities. How hard would it be to add the functionality of certain locations becoming populated by new cells due to proximity of other living cells?</p>

<h3 id="close-but-no-cigar">Close, but no cigar!</h3>

<p>Well, no. It didn’t save me the pain of a big refactoring.</p>

<p>Once I had to consider spawning locations the whole design fell to pieces. I was tracking living cells and the Cell class had responsibility over knowing its neighbors. Now that I needed to find a way to encompass both, tracking already living cells and looking for fertile locations where new cells could come to life, I saw that keeping track of and analyzing locations could achieve both things in a single stroke.</p>

<p>I could see 3 ways to go about it:</p>

<ol>
  <li>Topologically, considering only locations, like a potential field.</li>
  <li>Biologically, with a graph made of cells, which I traverse to decide if I create new ones in neighboring spaces.</li>
  <li>Topo for spawning locations and bio for living cells. May make the most natural sense, since spawning locations and living cells are different things, but I cannot see it being worth the extra level of complexity. A more complex setting could make me choose this route.</li>
</ol>

<p>On one hand, this high level understanding of the design could have been taken head-on from the start, saving me the extra miles walked down the cell path, to only retrace and re-code it as location based.</p>

<p>On the other hand, this process allowed me to never get stuck because of the complexity of the problem. I was always able to advance, even if it meant taking 2 steps forward and one back. If time is not a constraint this way feels natural and it flows.</p>

<p>Another benefit was that I could always relay on the test previously written. This is an immense aid and a boost to the confidence that the new route (big refactoring) works.</p>

<p>A final benefit is that the continuous refactoring ends up making the whole language more natural, the code minimized code and me having a deeper understanding of how everything works. The fact that I was building and breaking things continuously forced me to be always make things as clear and small as possible, so I wouldn’t get lost with all the commotion.</p>

<h3 id="disclaimer">Disclaimer</h3>

<p>The code was left unfinished. The GOL class should have a method ‘play’, a way to set the initial state of living cells from a text file (for example), and a way to visualize the evolution of the game in a fixed referenced window. The chart class itself, which visualizes the board, is messy and would benefit from refactoring.</p>

<p>Absolutely more tests are needed. I still need to work on really covering all possible scenarios for each class. I started strong but I have the feeling that I dropped the ball a bit by the end.</p>
]]></content>
  </entry>
  
</feed>
