<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails, | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2016-06-20T07:26:36-07:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Wiring Devise into Angular + Rails]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/30/Devise-Angular-Rails/"/>
    <updated>2014-10-30T16:17:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/30/Devise-Angular-Rails</id>
    <content type="html"><![CDATA[<h3 id="walk-through-to-use-devise-with-angular-in-rails-42">Walk-through to use Devise with Angular in Rails 4.2.</h3>

<p>This is more of a jump-through than a walk-through since I am going to be more jumping around the code than really walking it slowly. The reason for this is that I think it will be more valuable to have a general idea of how the wiring works than an excessively detailed view that may not apply to most cases (my example was very basic).</p>

<p>Include in your Gemfile devise and bundle. We request at least version 4.3.1 because of some troubles with previous versions and Rails 4.2.</p>

<p><code>ruby
gem 'devise', '~&gt; 3.4.1'
</code></p>

<p>Run the generator and follow the config steps suggested by the gem.</p>

<p><code>bash
$ rails g devise:install
</code></p>

<p>Make devise respond to json by adding the following to your application.rb:</p>

<p><code>ruby
config.to_prepare do
  DeviseController.respond_to :html, :json
end
</code></p>

<!-- more -->

<p>Generate the User model with devise:</p>

<p><code>bash
$ rails g devise user
</code></p>

<p>Don’t forget to floss, I mean <code>rake migrate</code>. Now, download the following modules from the angular site: [angular-cookies.js, angular-route.js] and place them where you have your angular file (in my case in app/assets/javascripts/). Make sure to add them to the application.js manifest after loading angular:</p>

<p><code>js
//= require jquery
//= require jquery_ujs
//= require angular.min
//= require angular-cookies.min
//= require angular-route.min
...
//= require_tree .
</code></p>

<p>Now, in my case I use the application layout to call the angular app.</p>

<p>```erb
<!-- application.html.erb -->
&lt;!DOCTYPE html&gt;
&lt;html data-ng-app="WhateverApp"&gt;</p>
<head>...</head>
<body>
    &lt;%= yield %&gt;
  </body>
<p>&lt;/html&gt;
```</p>

<p>Again, in my particular case all I have is a single Rails controller with a single action (index), and a single index view. In that index.html.erb we reference to angular routes:</p>

<p><code>erb
&lt;div data-ng-view&gt;&lt;/div&gt;
</code></p>

<p>In app/assets/javascript/angular_app/ we create a new file <code>routes.js</code> with the routes we want. In my case I have appended the .erb type so Rails pre-processes the erb tags:</p>

<p><code>javascript
(function() {
  var app = angular.module('GemStore');
  app.config(['$routeProvider', function($routeProvider) {
    $routeProvider
      .when('/store_front', {
        controller: 'Resource1Controller',
        templateUrl: '&lt;%= asset_path("angular_app/resource_1/views/store_forefront.html") %&gt;'
      })
      .when('/admin', {
        controller: 'UsersCtrl',
        templateUrl: '&lt;%= asset_path("angular_app/users/views/user_entrance.html") %&gt;'
      })
      .when('/dashboard', {
        controller: 'Resource2Ctrl',
        templateUrl: '&lt;%= asset_path("angular_app/resource_2/views/dashboard.html") %&gt;'
      })
      .otherwise({
        redirectTo: '/store_front'
      });
  }]);
})();
</code></p>

<p>The route /admin will take us to the User that Devise created and whose view is:</p>

<p>```javascript
&lt;div data-ng-controller="UsersCtrl"&gt;</p>
<div>
    <div data-ng-show="!isLoggedIn()">
      <button data-ng-click="setForm('signUp')"> Create User</button>
      <button data-ng-click="setForm('signIn')">Sign In</button>
    </div>
    <div data-ng-show="isLoggedIn()">
      <button data-ng-click="signOut()">Sign Out</button>
    </div>
  </div>
<p><br /><br /></p>

<form name="newUserForm" data-ng-show="form == 'signUp'">
    <label>Email</label>:
    <input type="text" required="" data-ng-model="newUser.email" />
    <label>Password</label>:
    <input type="password" required="" data-ng-model="newUser.password" />
    <label>Password confirmation</label>:
    <input type="password" required="" data-ng-model="newUser.password_confirmation" />

    <button data-ng-disabled="newUserForm.$invalid" data-ng-click="signUp(newUser)"> Create User</button>
  </form>

<form name="loginForm" data-ng-show="form == 'signIn'">
    <label>Email</label>
    <input type="text" required="" data-ng-model="user.email" />
    <label>Password</label>
    <input type="password" required="" data-ng-model="user.password" />
    <button data-ng-disabled="loginForm.$invalid" data-ng-click="signIn(user)">Sign In</button>
  </form>
<p>&lt;/div&gt;</p>

<p>&lt;button data-ng-click="StorePath()"&gt;Store Front&lt;/button&gt;
```</p>

<p>The different panels and buttons show and hide depending on if we are logged in or not. I included those functions in my top app.js and under the rootScope so they can be called from anywhere:</p>

<p>```javascript
app.run([‘$rootScope’,’$cookieStore’, ‘$location’, function($rootScope, $cookieStore, $location) {
    $rootScope.isLoggedIn = function() {
      return ($cookieStore.get(‘logged_user’) ? true : false);
    };</p>

<pre><code>$rootScope.logged_user = function() {
  return $cookieStore.get('logged_user').email;
};   }]); ```
</code></pre>

<p>Finally, the UserCtrl.js includes the way to connect to Rails, query the User model and set the cookies:</p>

<p>```javascript
(function(){
  var app = angular.module(‘GemStore’);</p>

<p>app.controller(‘UsersCtrl’, [
    ‘$scope’,’$http’,’$cookieStore’,’$location’,function($scope, $http, $cookieStore,$location){</p>

<pre><code>$scope.user = {};
$scope.new_user = {};

$scope.signUp = function(new_user){
  data = { user: new_user };
  $http.post('/users', data)
  .success(function(data){
    $scope.new_user = {};
    $cookieStore.put('logged_user', data);
    $scope.setForm('');
    $location.path('/dashboard');
  })
  .error(function(data, status){
    console.log(data);
    console.log(status);
  });
};

$scope.signIn = function(new_user){
  data = { user: new_user };
  $http.post('/users/sign_in', data)
  .success(function(data){
    $scope.user = {};
    $cookieStore.put('logged_user', data);
    $scope.setForm('');
    $location.path('/dashboard');
  })
  .error(function(data,status){
    console.log(data);
    console.log(status);
  });
};

$scope.signOut = function() {
  $http({
    method: 'DELETE',
    url: 'users/sign_out'
  })
    .success(function() {
      $cookieStore.remove('logged_user');
      $scope.setForm('');
      $location.path('/store_front');
    })
    .error(function(status) {
      console.log(status);
    })
};

$scope.setForm = function(form) {
  $scope.form = form;
};   }]); })() ```
</code></pre>

<p>Finally, make sure you are nullifying the sessions as you protect from CSRF attacks.</p>

<p>```ruby
class ApplicationController &lt; ActionController::Base
  respond_to :html, :json</p>

<p># Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  # protect_from_forgery with: :exception
  protect_from_forgery with: :null_session
end
```</p>

<p>Special thanks to Derek Maffett, whose help was invaluable to navigate the angular example.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Api Versioning]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/28/Rails-API-Versioning/"/>
    <updated>2014-10-28T16:17:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/28/Rails-API-Versioning</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/Oct14/versionapi.png" width="200" title="RailsCast" ></p>

<p>Rails provide a powerful framework to build your own API. But as you evolve your API will evolve too, your code will change and even your schema will mutate. That is OK as long as you have a rational way to structure the different versions of the api, how they are called and what they return.</p>

<p>There are different ways to achieve this versioning, I will be enumerating the pros and cons of three of them.</p>

<h3 id="pre-pend-the-ryan-bates-way">Pre-pend (the Ryan Bates Way)</h3>

<p><a href="http://railscasts.com">RailsCast</a>, the ultimate resource for all things rails, goes into specific details of how to manually set up your own versioning system in its <a href="http://railscasts.com/episodes/350-rest-api-versioning?view=asciicast">episode 350</a>.</p>

<p>It involves modifying your routes so your apis resources are encapsulated in namespaces. There are many advantages to this approach, first and foremost it forces you to be aware of what is happening, you learn your tool in the process and you don’t depend on external code (versioning gem).</p>

<p>On the other hand, you’ll end up with parallel versions of the same code living side by side, not the most DRY way to keep your code base. Furthermore, you are responsible for tracking changes to your schema, and then adapting and maintaining each of the version calls.</p>

<!--more-->

<p>Nevertheless, this is the approach I have generally used since it provides me with the most experience and learning.</p>

<p>You can actually have it both ways, pre-pending the api version and automating with a gem (up to a point) with the Versionist Gem, which provides three different ways to version your api out of the box:</p>

<ul>
  <li>Specifying version via an HTTP header</li>
  <li>Specifying version by pre-pending paths with a version slug</li>
  <li>Specifying version via a request parameter</li>
</ul>

<p>Pre-pending the path with a version slug is the same as the method discussed in RailsCast, visual, fast and intuitive. The problem is that the gem won’t move files for you so you’ll need to re-organize some files around and change some configuration details.</p>

<h3 id="request-header">Request Header</h3>

<p>The <a href="https://github.com/bploetz/versionist">Versionist</a> gem also allows us to include the version to use as a parameter in the header of the request call. Which has the benefits and disadvantages of hiding away this information in the header. It is less transparent and user friendly, but great for automated calls. Less opportunity to fudge at the cost of a higher initial cost of setting the system up.</p>

<h3 id="url-parameter">Url Parameter</h3>

<p>The third way Versionist can work is by appending the api version as a parameter at the end of the call, which although benefiting from being as somewhat visual, it fudges the url mixing resource parameters with unrelated information. This practice is frowned upon in the rails development community.</p>

<h3 id="mime-type">MIME Type</h3>

<p>You could register a MIME type for each api version and use the rails’ respond_to handle the response. Check Robbie Clutton <a href="http://pivotallabs.com/api-versioning/">post about it</a>.</p>

<p>The registration happens in the config/initializers/mime_types.rb, and all you need is to reconfigure your controllers.</p>

<h3 id="api-model">API Model</h3>

<p>Gems like <a href="https://github.com/craigs/api_versioning">ApiVersioning</a> use a model-based approach. Where a controller renamed as a <code>presenter</code>, handles API responses. It allows to specified the version in the header or passed as a parameter.</p>

<p>Thanks to Scot Hale who pointed me in the right direction in order to research this topic!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wiring Angular into Rails]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/27/Wire-Angular-Rails/"/>
    <updated>2014-10-27T20:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/27/Wire-Angular-Rails</id>
    <content type="html"><![CDATA[<p>Given an angular site of static pages, without persistent data, just the bells and whistles that Angular provides for the front end, how do we wire it so it is served from inside a Rails application.</p>

<p>The first step is to generate a new rails app (I used 4.2), for which we’ll create a controller that will coordinate the rendering of the angular app. We’ll start with a single action that points to a show template, where all the action will take place (it would substitute the index.html page of the Angular app). We call our controller StoreController.</p>

<p>In app/assets/javascripts/application.js we are going to remove turbolinks, because it is repetitive functionality now that we’ll be relying on Angular and it tends to screw things up. Actually we could remove it from the Gemfile too.</p>

<p><code>
# app/assets/javascripts/application.js
//= require jquery
//= require jquery_ujs
//= require angular.min
//= require launch_store
//= require_tree .
</code></p>

<p>We also add a requirement for a custom js file that we’ll create, app/assets/javascripts/launch_store.js, and where we declare our Angular app as gemStore.</p>

<p><code>
# app/assets/javascripts/launch_store.js
//= require_self
//= require_tree ./angular_store_app
(function(){
  var app = angular.module("GemStore", ["StoreDirectives"]);
})();
</code>
<!--more-->
In this newly loaded file we reference again another folder tree, ‘angular_store_app’, where we’ll store all the Angular functionality by resources. In our case we are using the resulting app from CodeSchool’s course “<a href="http://campus.codeschool.com/courses/shaping-up-with-angular-js/intro">Shaping up with Angular</a>”, a store-like app for displaying gems and jewels. Therefore we’ll create a subfolder called ‘gems’ and inside another three subfolders: controllers, directives, and views.</p>

<p><img class="center" src="/images/Oct14/folders.png" width="300"></p>

<p>Our convention is going to be to name directives in camelCase, and everything else in PascalCase.</p>

<p>Now all it is left to do is to add the controllers and directives to its respectives files:</p>

<p>```javascript
// gems_controller.js
(function(){
  var app = angular.module(‘GemStore’);
  app.controller(‘StoreController’, [‘$http’, ‘$scope’, function($http, $scope) {
    …
  ]);
})();</p>

<p>(function(){
  var app = angular.module(‘GemStore’);
  app.controller(‘ReviewController’, [‘$scope’, function($scope) {
  …
  });
})();</p>

<p>// gems_directives.js
(function() {
  var app = angular.module(“StoreDirectives”, []);
  app.directive(“productDescription”, function() {
    return {
      restrict: “A”,
      templateUrl: “&lt;%= asset_path(‘angular_store_app/gems/views/description.html’)%&gt;”
    };
  });
…
```</p>

<p>For the rails views we need to, first of all, make sure our routes are well defined and pointing to ‘store#show’.</p>

<p>Then in the application.html.erb we reference the angular app (check that we have taken out the turbolinks):</p>

<p>```html
&lt;!DOCTYPE html&gt;
&lt;html data-ng-app="GemStore"&gt;</p>
<head>
  <title>Angurails</title>
  &lt;%= stylesheet_link_tag 'application', media: 'all' %&gt;
  &lt;%= javascript_include_tag 'application' %&gt;
  &lt;%= csrf_meta_tags %&gt;
</head>
<body>

&lt;%= yield %&gt;

</body>
<p>&lt;/html&gt;
```</p>

<p>And in the show.html.page of the store controller we can start coding our own angular references and expressions:</p>

<p>```html
&lt;div data-ng-controller="StoreController"&gt;</p>
<header>
    <h2 class="text-center">Soto's Magnificent Emporium</h2>
    <h3 class="text-center"> an sinangular store </h3>
  </header>

<div class="list-group">
    <div class="list-group-item" data-ng-repeat="product in products">
      <h3> <em class="pull-right"></em></h3>
      <div data-product-gallery=""></div>
      <div data-product-tabs=""></div>
    </div>
  </div>
<p>&lt;/div&gt;
```</p>

<p>One last details is to include in the rails public folder our angular html snippets referenced by directives, and make sure that the url in the gems_directives.js are correct.</p>

<p>```html
<!-- app/assets/javascript/angular_store_app/gems/views/description.html -->
&lt;div data-ng-show="tab.isSet(1)"&gt;</p>
<h4>Description</h4>
<blockquote></blockquote>
<p>&lt;/div&gt;
```</p>

<p>That’s it. Run it and check it works.</p>

<p>One final note of advice, in my case using CoffeeScript gave me quite a bit of trouble, and although I still have to investigate the exact causes of the it, I recommend to use it with caution.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails BDD cheats]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/09/17/Rails-BDD/"/>
    <updated>2014-09-17T18:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/09/17/Rails-BDD</id>
    <content type="html"><![CDATA[<p>As a reminder, when testing BDD style a Rails app these are helpful to have close by:</p>

<p>```ruby
# Rakefile
require File.expand_path(‘../config/application’, <strong>FILE</strong>)</p>

<p>Rails.application.load_tasks</p>

<p>Rails::TestTask.new(‘test:features’ =&gt; ‘test:prepare’) do |t|
  t.pattern = ‘test/features/<em>*/</em>_test.rb’
end</p>

<p>Rake::Task[‘test:run’].enhance [‘test:features’]</p>

<p>task default: ‘test’
```</p>

<p>```ruby
# test_helper.rb
# ENV[‘RAILS_ENV’] ||= ‘test’
Rails.env = ‘test’
puts “Current environment: #{Rails.env}”</p>

<p>require File.expand_path(‘../../config/environment’, <strong>FILE</strong>)
require ‘rails/test_help’
require ‘minitest/rails/capybara’
require ‘capybara/poltergeist’
# require ‘pry-rescue/minitest’</p>

<p>class ActiveSupport::TestCase
  fixtures :all
  Capybara.javascript_driver = :poltergeist
end
```</p>

<p>```ruby
# test/features/do_some_test.rb
require ‘test_helper’</p>

<p>feature ‘Do something’ do
  scenario ‘anybody can do something’ do
    …
  end
end
```</p>
]]></content>
  </entry>
  
</feed>
