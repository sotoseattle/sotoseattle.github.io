<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Primo | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/primo/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2014-11-01T20:07:20-07:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PRIMO: Factors]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/07/17/Primo-Factors/"/>
    <updated>2014-07-17T08:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/07/17/Primo-Factors</id>
    <content type="html"><![CDATA[<h2 id="factor">Factor</h2>

<p>The best way to visualize a Factor is in terms of an n-dimensional matrix. Each dimension (or axis) corresponds to a random variable. These variables are held in the <code>@vars</code> instance variable.</p>

<p>Each axis has as many possible values as its cardinality. A Factor made of two binary variables (x, y) will be similar to a 2x2 matrix.</p>

<p>For example, given two random variables that represent the toss of a coin, both being binary (head or tails) would give us the following factor:</p>

<table class="widetable">
  <thead>
    <tr>
      <th> </th>
      <th>head</th>
      <th>tails</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>head</td>
      <td>p(h &amp; h)</td>
      <td>p(h &amp; t)</td>
    </tr>
    <tr>
      <td>tails</td>
      <td>p(t &amp; h)</td>
      <td>p(t &amp; t)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>In tabular form we have:</p>

<table class="widetable">
  <thead>
    <tr>
      <th>outcome</th>
      <th>probability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>head &amp; head</td>
      <td>p(h &amp; h)</td>
    </tr>
    <tr>
      <td>head &amp; tail</td>
      <td>p(h &amp; t)</td>
    </tr>
    <tr>
      <td>tail &amp; head</td>
      <td>p(t &amp; h)</td>
    </tr>
    <tr>
      <td>tail &amp; tail</td>
      <td>p(t &amp; t)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>So apart from the variables it holds, the Factor also keeps track of the values of all possible outcomes, the <code>@vals</code>. These will be the probabilities of the outcomes in most cases.</p>

<p>Now, the vars are kept in an array, and the vals are stored in an N-array, a multidimensional array, where each dimension correspond to a random variable.</p>

<h2 id="operations">Operations</h2>

<h3 id="multiplication-and-addition">Multiplication and Addition</h3>

<p>Let’s begin by saying that like the previous operations these methods:</p>

<ul>
  <li>modify the first element ( a * b =&gt; a is changed)</li>
  <li>allow multiplying/adding by number (elementwise) or factor</li>
  <li>override the common operators (* == multiply factors, + == add factors)</li>
  <li>returns itself so we can chain operations (f1 * f2 * f3)</li>
</ul>

<p>The key methods. Given two factors I modify each one by:</p>

<ul>
  <li>gathering all the variables of the resulting multiplication factor (union of all sorted variables)</li>
  <li>inserting new axis in each factor for each new variable that it doesn’t have. This way both factors will have the same axes, in the same order (by the way, this is the reason why we needed a way to sort random variables by id). This is accomplished with simple rotations of the NArray.</li>
  <li>expanding the values ndarray on each new axis by simply repeating existing values a number of times equal to the cardinality of the axi’s variable.</li>
</ul>

<p>Continuing with the graphic example, to expand our previous factor (variables v1 and v2) by another variable (v3) we would start with the 2D values along axes v1, v2. Then we add a third dimension for v3.</p>

<p><img class="center" src="/images/nov13/multiply1.png"></p>

<p>And then we repeat the 2D matrix (v1,v2) along the v3 axis. In our case v1 and v2 have cardinality 2 and v3 has cardinality 3 so we repeat the 2D matrix twice more along the v3 axis.</p>

<p><img class="center" src="/images/nov13/multiply2.png"></p>

<p>At the end of the process we have two NArrays that represent the same variables, aligned and of the same shape. To multiply/add we only need to multiply/add them element wise. At the end of the day, this Ruby method is 30% smaller and yet faster than the python version.</p>

<p>```ruby Factor Multiplication &amp; Addition
def <em>(other)
  other.is_a? Numeric ? self.vals = vals * other : modify_by(other, &amp;:</em>)
  self
end</p>

<p>def +(other)
  other.is_a? Numeric ? self.vals = vals + other : modify_by(other, &amp;:+)
  self
end</p>

<p>def modify_by(other, &amp;_block)
  return self unless other
  all_vars = [*vars, *other.vars].uniq.sort</p>

<p>narr1 = grow_axes(all_vars)
  narr2 = other.grow_axes(all_vars)
  na = yield narr1, narr2</p>

<p>self.vars = all_vars
  self.vals = na.reshape!(*cardinalities)
  self
end</p>

<p>def grow_axes(whole_vars)
  return vals.flatten if vars == whole_vars</p>

<p>multiplier = 1.0
  new_vars = whole_vars.reject { |rv| vars.include?(rv) }</p>

<p>old_order_vars = [*vars, *new_vars]
  new_order = whole_vars.map { |e| old_order_vars.index(e) }</p>

<p>new_cards = cardinalities(new_vars)
  multiplier = new_cards.reduce(multiplier, :*)</p>

<p>flat = [vals.flatten] * multiplier
  na = NArray.to_na(flat).reshape!(*vals.shape, *new_cards)</p>

<p>if new_order != [<em>(0..whole_vars.size)]
    na = na.transpose(</em>new_order)
  end</p>

<p>na.flatten
end
```</p>

<h3 id="marginalization">Marginalization</h3>

<p>We want to eliminate a dimension, (a variable or axis), by adding all values along the eliminated axis. We alias the method to the modulus operator <code>%</code> for syntactical convenience.</p>

<p>It allows for chaining operations i.e. f1 % v1 % v2 eliminates in order, first v1 from f1, and then v2 from the resulting factor. Each time % kicks in, f1 is modified in place.</p>

<p>If for example, the factor f1, has only those two random variables (v1, v2), reducing on v2 means selecting the axis for v2 and for each row of v1, adding up all columns of v2.</p>

<p><img class="center" src="/images/nov13/margin.png"></p>

<p>The method marginalize_but is a fast implementation of marginalizing in bulk for all variables in the factor except for one that we want to extract. In this operation we end up with the final probabilities of all assignments for that selected random variable.</p>

<h3 id="reduction">Reduction</h3>

<p>Set values to 0.0 based on observed variables. For example, given a random variable of color that can only take two possible values (red, blue).i If we know that the color is red, then p(blue)=0.0.</p>

<p>We modify the NArray values by 1) selecting the observed variable axis and leaving all other axis untouched, and 2) for the selected axis, setting to 0. all cells that are not in the observation column.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PRIMO: Random Variables]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/07/16/Primo-Random-Var/"/>
    <updated>2014-07-16T08:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/07/16/Primo-Random-Var</id>
    <content type="html"><![CDATA[<h2 id="als-primo">Alás Primo!</h2>

<p>I have decided to code all this in Ruby instead of Python. The reason being that Ruby is more flexible in order to build prototypes that encompass all aspects of the functionality. The apps that I would like to build around ML are like cars. The engine may be a key component and its performance paramount, but there is more to a car than its engine. Our apps will be more than its inference engine, and in all those other aspects Ruby shines. If I was obsessed only with the engine I would have code it all in Julia or C, but I am in this for the fun and the possibilities, and Ruby is a pleasure to play with.</p>

<p>Besides, what I have already coded in Ruby is already faster than my Python code (which shows what a beginner I am in Python). The key to the performance boost has been the use of the <a href="http://masa16.github.io/narray/">NArray gem from Masahiro Tanaka</a>, which allows me to, for example, multiply two multidimensional arrays element wise in a single step, after aligning them with simple rotations of their axes (actually pretty cool).</p>

<p>I have christened this working library as PRIMO (Probabilistic Inference Modeling), and the code is available at https://github.com/sotoseattle/PRIMO</p>

<p>It works along the same lines as the Python version so the following posts will be a bit repetitive since we are rehearsing much of what was done months ago in Python. This is an ongoing effort that I hope to culminate with a working CRF application that estimates its own parameters.</p>

<h2 id="random-variables">Random Variables</h2>

<p>The essential building block of Primo, similar to Nodes in graphs, each holds the following instance variables:</p>

<ul>
  <li><strong>cardinality</strong>. For example, a binary variable that can only take two values (true-false, 0-1) and therefore it has a cardinality of 2. The roll of a dice would have cardinality of 6, because the the outcome can take 6 different values: 1, 2, 3, 4, 5 or 6.</li>
  <li><strong>ass</strong> (assignments). An ordered array with all the possible assignments. If no assignments are given it uses integers starting from 0. The previous dice roll would have an ass of [0, 1, 2, 3, 4, 5]; a binary variable would have an ass of [0, 1]. We can also make a binary random variable for the health of a patient with the assignment array [‘healthy’, ‘sick’].</li>
  <li><strong>name</strong>. Just a name to make it easier to identify the variable.</li>
</ul>

<p>An important detail is how we define the &lt;=&gt; operator because we will be comparing between random variables based on their internal object ids. This is necessary because later on, when we multiply sets of variables, we will do it according to their order. The order itself doesn’t matter, all we’ll need is that there is a way to order them in a stable, immutable and persistent way.</p>

<p>```ruby
  def initialize(args)
    args.merge(name: ‘’, ass: nil)</p>

<pre><code>@card = args[:card].to_i
@name = args[:name].to_s
@ass = args[:ass] ? Array(args[:ass]) : [*0...@card]

fail ArgumentError if @card == 0 || @ass.size != @card   end
</code></pre>

<p>def &lt;=&gt;(other)
    object_id &lt;=&gt; other.object_id
  end</p>

<p>def [](assignment)
    ass.index(assignment)
  end</p>

<p>def to_s
    “#{name}”
  end
end
```</p>
]]></content>
  </entry>
  
</feed>
