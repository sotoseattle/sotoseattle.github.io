<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Metaprogramming | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/metaprogramming/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2014-10-31T13:43:30-07:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Metaprogramming II]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/24/Binary-Tree-Meta/"/>
    <updated>2014-10-24T08:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/24/Binary-Tree-Meta</id>
    <content type="html"><![CDATA[<p>This is a follow up to my path of learning Ruby Metaprogramming. It follows my previous post about the <a href="/blog/2014/10/05/Metaprogramming/">Equalizer gem</a>.</p>

<p>For this exercise we are going to start with a basic BinaryTree that consists of nodes that just hold a key (val), and two links to the left and right children. This is not a BST, just a raw binary tree where each node is considered a tree in itself.</p>

<p>```ruby
class BinaryTree
  attr_accessor :val, :left, :right</p>

<p>def initialize(val)
    @val = val
    @left = @right = nil
  end
end
```</p>

<p>For our example we are going to create an ad-hoc tree that we wire in the following manner.</p>

<p><img class="center" src="/images/Oct14/binary_tree.png" width="300"></p>

<!--more-->

<p>```ruby
tim    = BinaryTree.new(‘Tim’)
phil   = BinaryTree.new(‘Phil’)
jony   = BinaryTree.new(‘Jony’)
dan    = BinaryTree.new(‘Dan’)
katie  = BinaryTree.new(‘Katie’)
craig  = BinaryTree.new(‘Craig’)
eddie  = BinaryTree.new(‘Eddie’)
peter  = BinaryTree.new(‘Peter’)
andrea = BinaryTree.new(‘Andrea’)</p>

<p>tim.left, tim.right = jony, phil
jony.left, jony.right = dan, katie
katie.left, katie.right = peter, andrea
phil.left, phil.right = craig, eddie
```</p>

<p>For this exercsie we are only interested in traversing the tree and outputting to stdout the names of each node. There are three different ways to perform this traversal in a depth-first fashion: pre-order, in-order and post-order. You can read the details about each one in this <a href="http://en.wikipedia.org/wiki/Tree_traversal">Wikipedia page</a>.</p>

<p>After a bit of reflection and sandboxing, a good and common-sense way to implement becomes clear:</p>

<p>```ruby
def traverse_pre_order
  puts val
  left.traverse_pre_order if left
  right.traverse_pre_order if right
end</p>

<p>def traverse_in_order
  left.traverse_in_order if left
  puts val
  right.traverse_in_order if right
end</p>

<p>def traverse_post_order
  left.traverse_post_order if left
  right.traverse_post_order if right
  puts val
end
```</p>

<p>The code is clear and readable, yet suffers from some repetition. We also see a pattern emerging: in all cases we recursively call the traverse method first on the left and then on the right, and the position of the call to stdout depends on the specific flavor of traversal:</p>

<ul>
  <li>pre =&gt; first call</li>
  <li>in  =&gt; between left and right</li>
  <li>post =&gt; after both calls</li>
</ul>

<p>This is a great opportunity to tinker with metaprogramming to see if we can do better. I focus on leveraging Ruby’s define_method, which allows us to create multiple methods with a single definition.</p>

<p><code>ruby
%w[pre in post].each do |prefix|
  define_method("traverse_#{prefix}_order") do
    # statements_to_execute = [traverse_left, traverse_right]
    # insert the puts call in the right place depending on the prefix
    # execute the array of orders one by one
  end
end
</code></p>

<p>The idea is to have an array made of little bunches of code to execute. Then we can manipulate the order in which those code snippets are executed by re-ordering the array. The array becomes something like an instructions book, an ordered set of steps to perform.</p>

<p>To insert the chunks of code in the array, we need to package them into objects. A solution is to wrap them as blocks of functionality as Proc objects (I have used stabby lambdas). To execute one of these object we just call it to yield.</p>

<p><code>ruby
instructions = [
  -&gt; { left.traverse_pre_order if left },
  -&gt; { right.traverse_pre_order if right }
]
</code></p>

<p>Now, is only a question of changing the order of the array of statements and adapt it to each flavor of traversal. Once the array is reshuffled to our taste, we iterate over each cell, anc execute the proc.</p>

<p>Here is the final code of the complete class unrefactored. I have taken advantage of the yet to be defined method inside, it cannot get more dynamic than that!</p>

<p>```ruby
class BinaryTree
  attr_accessor :val, :left, :right</p>

<p>def initialize(val)
    @val = val
    @left = @right = nil
  end</p>

<p>%w[pre in post].each_with_index do |prefix, index|
    define_method(“traverse<em>#{prefix}_order”) do
      instructions = [
        -&gt; { left.public_send(“traverse</em>#{prefix}<em>order”) if left },
        -&gt; { right.public_send(“traverse</em>#{prefix}_order”) if right }]
      do_stuff = -&gt; { puts val }
      instructions.insert(index, do_stuff)
      instructions.each { |x| x.yield }
    end
  end
end
```</p>

<p>Specially interesting is how the scoping works, which I’ll leave for a future post. Stay tunned!</p>

<p>Here is the final version, refactored, plus some tests.</p>

<p>```ruby
class BinaryTree
  attr_accessor :val, :left, :right</p>

<p>def initialize(val)
    @val = val
    @left = @right = nil
  end</p>

<p>%w[pre in post].each_with_index do |prefix, index|
    define_method(“traverse_#{prefix}_order”) do
      instructions(prefix).insert(index, do_stuff).each(&amp;:yield)
    end
  end</p>

<p>private</p>

<p>def do_stuff
    -&gt; { puts val }
  end</p>

<p>def instructions(prefix)
    [left, right].map { |e| -&gt; { e.send(“traverse_#{prefix}_order”) if e } }
  end
end
```</p>

<p>```ruby
require ‘spec_helper’</p>

<p>describe BinaryTree do
  describe ‘Search Methods’ do
    let(:bt) { # tim as defined above }
    it ‘BinaryTree#traverse_pre_order’ do
      proc { bt.traverse_pre_order }.must_output “Tim\nJony\nDan\nKatie\nPeter\nAndrea\nPhil\nCraig\nEddie\n”
    end</p>

<pre><code>it 'BinaryTree#traverse_in_order' do
  proc { bt.traverse_in_order }.must_output "Dan\nJony\nPeter\nKatie\nAndrea\nTim\nCraig\nPhil\nEddie\n"
end

it 'BinaryTree#traverse_post_order' do
  proc { bt.traverse_post_order }.must_output "Dan\nPeter\nAndrea\nKatie\nJony\nCraig\nEddie\nPhil\nTim\n"
end   end end ```
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Metaprogramming in Action]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/05/Metaprogramming/"/>
    <updated>2014-10-05T08:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/05/Metaprogramming</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/dkubb/equalizer">Equalizer gem</a> provides a nifty example of Ruby metaprogramming.</p>

<p>It is a module that when added to your class helps define equality, equivalence and inspection methods.</p>

<p>```ruby
class GeoLocation
  include Equalizer.new(:latitude, :longitude)</p>

<p>attr_reader :latitude, :longitude</p>

<p>def initialize(latitude, longitude)
    @latitude, @longitude = latitude, longitude
  end
end</p>

<p>point_a = GeoLocation.new(1, 2)
point_b = GeoLocation.new(1, 2)</p>

<p>point_a.inspect    # =&gt; “#&lt;GeoLocation latitude=1 longitude=2&gt;”</p>

<p>point_a == point_b           # =&gt; true
point_a.hash == point_b.hash # =&gt; true
```
<!--more-->
## Include instance of a Module?</p>

<p><code>ruby
# example
class GeoLocation
  include Equalizer.new(:latitude, :longitude)
...
</code></p>

<p>The first thing that calls the attention when reading the code is the instantiation of the module. What? Weren’t modules used to be abstract, nice little packages of functionality, angelical and stateless, devoid of the tribulations of commoner fleshed-out Objects?</p>

<p>In Ruby everything is an Object, and the following two ways of coding a module are equivalent:</p>

<p>```ruby
module Insane
  def hello
    ‘hola’
  end
end</p>

<p>Insane = Module.new do
  def hello
    ‘hola’
  end
end
```</p>

<p>Let’s inspect the Equalizer’s code:</p>

<p>```ruby
# equalizer.rb
class Equalizer &lt; Module
  def initialize(*keys)
    @keys = keys
    define_methods
    freeze
  end
  …
end</p>

<h1 id="example">example</h1>
<p>class GeoLocation
  include Equalizer.new(:latitude, :longitude)
  …
```</p>

<p>In the last line lies the rub, the double nature of Equalizer.</p>

<ol>
  <li>Equalizer is a Module and by ‘including’ it, GeoLocation makes all methods from Equalizer available to his objects.</li>
  <li>Yet Equalizer is defined as a class that can be instantiated.</li>
</ol>

<p>But we have seen that everything is an object and there is no need to make it a class object, so the instantiation must serve a different purpose.</p>

<p>Yes, by defining Equalizer as a class that can be instantiated, at that moment of instantiation we can pass the specific instance variables in an instant (sorry!) to customize those methods based on the keys passed (latitude and longitude). So Equalizer defines methods based on something undefined (keys), and only at inclusion (when we know which are the instance variables to make comparable) it customizes its module’s methods on the fly.</p>

<p>Although stateless, Equalizer is able to be adapt to the circumstances of each class that will include it. In our example, at instantiation it uses GeoLocation’s latitude and longitude to redefine its methods at the last minute, to the effect of adding to them the ability to be comparable.</p>

<p>Let’s check it works:</p>

<p>```ruby
class Insane &lt; Module
  def initialize(key)
    define_method(“#{key}?”) { ‘God!’ }
  end
end</p>

<p>class Person
  attr_reader :who_am_i
  include Insane.new(:who_am_i)</p>

<p>def initialize(name)
    @who_am_i = name
  end
end</p>

<p>a = Person.new(‘javier’)
puts “a.who_am_i = #{a.who_am_i}”
=&gt; a.who_am_i = javier
puts “a.who_am_i? = #{a.who_am_i?}”
=&gt; a.who_am_i? = God!
```</p>

<p>Convoluted, pirouetticall, and yet it works.</p>

<h2 id="define-method">Define Method</h2>

<p>Among other metaprogramming tricks it uses the define_method extensively. Although this is usually done to create a new named method at runtime, in this case, the method’s names are set from the start, what is created dynamically is the way the method operates.</p>

<p>For example, the cmp? (comparable?) method has a set name (cmp?) and the blocks passed is also well defined (we check that all keys of both objects return the same values), but the fact that we won’t know which keys are available to compare until runtime makes this use an example of metaprogramming.</p>

<p>```ruby
# where we make attributes comparable
def define_cmp_method
  keys = @keys
  define_method(:cmp?) do |comparator, other|
    keys.all? { |key| send(key).send(comparator, other.send(key)) }
  end
  private :cmp?
end</p>

<h1 id="the-comparisson-method">The comparisson method</h1>
<p>def ==(other)
  other = coerce(other) if respond_to?(:coerce, true)
  other.is_a?(self.class) &amp;&amp; cmp?(<strong>method</strong>, other)
end
```</p>

<p>Two notes:</p>

<ol>
  <li>
    <p>The cmp? method is just a DRY method used to define the real comparison methods (eql? and ==). This way it is easy to extend.</p>
  </li>
  <li>
    <p>Consider also that we include this Equalizer class as an instantiated object when defining the class, so when we instantiate a new object all Equalizer methods are available as instance methods already defined for the existing instance variables.</p>
  </li>
</ol>
]]></content>
  </entry>
  
</feed>
