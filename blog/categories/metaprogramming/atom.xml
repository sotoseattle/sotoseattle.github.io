<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Metaprogramming | SotoSeattle]]></title>
  <link href="http://sotoseattle.github.io/blog/categories/metaprogramming/atom.xml" rel="self"/>
  <link href="http://sotoseattle.github.io/"/>
  <updated>2014-10-23T15:47:05-07:00</updated>
  <id>http://sotoseattle.github.io/</id>
  <author>
    <name><![CDATA[Javier Soto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Metaprogramming in Action]]></title>
    <link href="http://sotoseattle.github.io/blog/2014/10/05/Metaprogramming/"/>
    <updated>2014-10-05T08:01:00-07:00</updated>
    <id>http://sotoseattle.github.io/blog/2014/10/05/Metaprogramming</id>
    <content type="html"><![CDATA[<p>The <a href="github.com/dkubb/equalizer">Equalizer gem</a> provides a nifty example of Ruby metaprogramming.</p>

<p>It is a module that when added to your class helps define equality, equivalence and inspection methods.</p>

<p>```ruby
class GeoLocation
  include Equalizer.new(:latitude, :longitude)</p>

<p>attr_reader :latitude, :longitude</p>

<p>def initialize(latitude, longitude)
    @latitude, @longitude = latitude, longitude
  end
end</p>

<p>point_a = GeoLocation.new(1, 2)
point_b = GeoLocation.new(1, 2)</p>

<p>point_a.inspect    # =&gt; “#&lt;GeoLocation latitude=1 longitude=2&gt;”</p>

<p>point_a == point_b           # =&gt; true
point_a.hash == point_b.hash # =&gt; true
```</p>

<p>Among other metaprogramming tricks it uses the define_method extensively. Although this is usually done to create a new named method at runtime, in this case, the method’s names are set from the start, what is created dynamically is the way the method operates.</p>

<p>For example, the cmp? (comparable?) method has a set name (cmp?) and the blocks passed is also well defined (we check that all keys of both objects return the same values), but the fact that we won’t know which keys are available to compare until runtime makes this use an example of metaprogramming.</p>

<p>```ruby
# where we make attributes comparable
def define_cmp_method
  keys = @keys
  define_method(:cmp?) do |comparator, other|
    keys.all? { |key| send(key).send(comparator, other.send(key)) }
  end
  private :cmp?
end</p>

<h1 id="the-comparisson-method">The comparisson method</h1>
<p>def ==(other)
  other = coerce(other) if respond_to?(:coerce, true)
  other.is_a?(self.class) &amp;&amp; cmp?(<strong>method</strong>, other)
end
```</p>

<p>Two notes:</p>

<ol>
  <li>
    <p>The cmp? method is just a DRY method used to define the real comparison methods (eql? and ==). This way it is easy to extend.</p>
  </li>
  <li>
    <p>Consider also that we include this Equalizer class as an instantiated object when defining the class, so when we instantiate a new object all Equalizer methods are available as instance methods already defined for the existing instance variables.</p>
  </li>
</ol>
]]></content>
  </entry>
  
</feed>
