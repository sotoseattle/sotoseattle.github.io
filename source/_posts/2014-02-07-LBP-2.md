---
layout: post
title: "Loopy Belief Propagation (II)"
date: 2014-02-7 08:01
comments: true
categories: PGN, theory
---

I am going to start abstracting the behavior of the cluster graph class, since Clique Tree and Bethe Graphs are specific cases of cluster graphs and inherit from it common methods. To begin with, I only keep here the way to compute messages. I'll add more through later refactorization.

```python Cluster Graph
class ClusterGraph(UndGraph, object):
    
    def mssg(self, from_v, to_w):
        mess = []
        neighbors = self.adj[from_v]
        for n in neighbors:
            if n!=to_w:
                pos = self.adj[n].index(from_v)
                msg = self.delta[n][pos]
                mess.append(msg)    
        # the initial Psi
        d = self.factors[from_v]
        # multiply by incoming messages
        for ms in mess:
            d = FactorOperations.multiply(d, ms, True)  #### NORMALIZING
        # marginalized to setsep vars
        for n in d.variables:
            if n not in (self.box[from_v] & self.box[to_w]):
                d = FactorOperations.marginalize(d, n)
        return d
```

For the specific case we are working on, since I don't know how to create other cluster graphs beyond the Bethe, I put everything under its name. Reading the code we see that the initialization comes from the BetheNetwork, the message passage schedule is a modified BFS (almost verbatim to Clique Tree), and the main difference is in the way we calibrate. Now we cycle through firing messages, and only stop when for a whole sequence (all messages sent on all edges) there is no material diference in the messages passed (all values of all messages before and after sent are less than a tolerance value).

Either convergence is achieved or we cycle more than 1,000, in either way we stop and with whatever data we have available we compute the beliefs.

```python Bethe Cluster Graph
class BetheGraph(ClusterGraph, object):

    def __init__ (self, singletonFactors, MultivarFactors):
        # we assume the cluster graph is built beforehand
        listOfFactors = singletonFactors
        n_singles = len(listOfFactors)
        
        listOfFactors.extend(MultivarFactors)
        self.V = len(listOfFactors)
        set_vars = [sorted(set(fu.variables)) for fu in listOfFactors]
        super(BetheGraph, self).__init__(set_vars)
        
        self.factors = listOfFactors
        
        for i in range(n_singles, len(listOfFactors)):
            for v in self.box[i]:
                for j in range(n_singles):
                    if v in self.box[j] and i!=j:
                        self.addEdge(i, j)
        
        # clone an initialized adj structure for message propagation
        # and create initial messages all to ones
        self.delta = [[None]*size(self.adj[i]) for i in range(self.V)]
        for from_v in range(self.V):
            for to_w in self.adj[from_v]:
                pos = self.adj[from_v].index(to_w)
                vars_passed = self.box[from_v].intersection(self.box[to_w])
                fu = Factor.Factor(sorted(list(vars_passed)))
                fu.values = np.ones(fu.cards)
                self.delta[from_v][pos] = fu
    
    def calibrate(self):
        self.beta = [None]*self.V
        path = self.computePath()
        
        #prev_deltas = np.array([c for a in copy.copy(self.delta) for b in a for c in b.values])
        keep_going = True
        cycles, messages = 0, 0
        while keep_going:
            cycles +=1
            keep_going = False
            for e in path:
                from_v, to_w = e
                pos_to = self.adj[from_v].index(to_w)
                # multiply factor in node self.factor[from_v] with incoming mssg
                messages +=1
                prev_res = self.delta[from_v][pos_to].values
                self.delta[from_v][pos_to] = self.mssg(from_v, to_w)
                new_res = self.delta[from_v][pos_to].values
                if not np.allclose(new_res, prev_res, 1e-12):
                    keep_going = True
            
            if cycles>1000:
                print 'SHIT! IT IS TAKING TOO LONG, ABORT!'
                keep_going = False
        
        print 'Cycles:', cycles, 'Messages passed', messages
        # compute the beliefs
        for v in range(self.V):
            belief = self.factors[v]
            for w in self.adj[v]:
                pos = self.adj[w].index(v)
                delta = self.delta[w][pos]
                belief = FactorOperations.multiply(belief, delta, True) #### NORMALIZING
            self.beta[v] = belief

    def computePath(self):
        '''Still using reversed BFS as default'''
        start = None # choose an arbitrary min-neighbor node
        mino = float('inf')
        for i in range(self.V):
            new_min = size(self.adj[i])
            if new_min<mino:
                start = i
                mino = new_min
        forward = BFS_Paths(self, start).discoveryPath
        forward.pop() # we dont need the last node
        
        temp = []
        marked = [False]*self.V
        for from_v in forward:
            neighbors = self.adj[from_v]
            marked[from_v] = True
            potentials = [n for n in neighbors if not marked[n]]
            for q in potentials:
                to_v = q
                temp.append([from_v, to_v])
        edges = temp
        for e in reversed(temp):    
            edges.append(e[::-1])
        return edges
```

The nice thing is that we can use the small Ising grid (n=3) to both run exact inference (as clique tree) and loopy belief propagation, so we can compare results.

For the case where all pairwise potentials are 0.5 (on and off diagonal), LBP only needs 2 cycles to achieve convergence, and the marginals are exact (coincide with results given by clique tree).

If we start screwing things up by distancing the values between the diagonal and the rest things start changing. For example, with pairwise potentials of [0.7, 0.3], to achieve convergence the Bethe needs 9 cycles, 432 messages passed, and the approximate marginals are pretty much on the mark!

|var| exact marginal | approx. marg (LBP)|
|:-:|---------------:|---------------:|
||||
|0  | 0.397366060615 | 0.394122247658|
|1  | 0.424979590531 | 0.423293282411|
|2  | 0.445407803138 | 0.447301221331|
|3  | 0.475570349842 | 0.479431838868|
|4  | 0.6            | 0.622892947007|
|5  | 0.622150908803 | 0.641436349469|
|6  | 0.618791664308 | 0.632073831741|
|7  | 0.66867562514 | 0.692517183179|
|8  | 0.665842695853 | 0.683969083626|
{:.widetable}
<br/>


Here is the code to run it:

```python Running
n = 3
t1 = ToyNetwork(n, weights=[.7, .3])
CG = BetheGraph(t1.factors[:n*n], t1.factors[n*n:])
CG.calibrate()

# EXACT MARGINALS
cc = CliqueTree(t1.factors)
cc.calibrate()
sol = [None]*t1.V
for belief in cc.beta:
    vs = belief.variables
    for x in vs:
        if sol[x.id]==None:
            b = copy.copy(belief)
            new_set = [a for a in vs if a!=x]
            for y in new_set:
                b = FactorOperations.marginalize(b, y)
            sol[x.id] = FactorOperations.normalize(b.values)

for i,e in enumerate(sol):
    print 'var', i, ":", e[0], '----', CG.beta[i].values[0]
```

The problem is that as we unbalance the potentials the LBP starts giving us very bad results. For example, for [1.0, 0.2] we need 13 cycles, 624 messages and even at convergence the results are way off:

|var| exact marginal | approx. marg (LBP)|
|:-:|---------------:|---------------:|
||||
|0  | 0.537310955208 | 0.841504523883 |
|1  | 0.556558936419 | 0.888905344335 |
|2  | 0.552439017812 | 0.861003173355 |
|3  | 0.573509953445 | 0.913335600629 |
|4  | 0.6            | 0.973450365328 |
|5  | 0.607090867757 | 0.953516447573 |
|6  | 0.611810074317 | 0.92709223937 |
|7  | 0.621715017707 | 0.966544220838 |
|8  | 0.626241528067 | 0.942899850003 |
{:.widetable}
<br/>

Loopy Propagation doesn't promise you to converge, and if it does converge it doesn't mean it has to end up somewhere near the exact marginal. There are three things that make this behavior the more probable: 1) having tight loops, 2) having spiked potentials (or big differences), and 3) having conflicting directions (two nodes tend to agree on a cycle, and disagree in another). Tomorrow I am going to research alternative ways to pass messages and other potential tricks to aid the LBP.