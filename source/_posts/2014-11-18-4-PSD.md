---
layout: post
title: "4 Principles of Simple Design Reflections"
date: 2014-11-18 10:17
comments: true
categories: Ruby
---

Following my previous post I have been thinking about the 4 Principles of Simple Design, their meaning and their applications to the little coding exercise of the Game of Life. These principles are:

1. Code pases tests => test drive development
2. Code reveals intent => can be read and understood, expressive
3. DRY => more in terms of knowledge than code
4. Code is simple, minimal => the least code to do/express the most

I really like the idea of priorities, of never violating higher level principles. So if you can compress a complex method into a single clever line, you don't do it if it becomes less readable, if it becomes confusing and difficult to understand. So first and foremost, pass the tests, make sure the code does what is supposed to do, that it adds value. Then make it accessible, etc. And find compromises among the principles never losing sight of where the priorities stand.

A big lesson learned is not to be afraid of throwing away code. You lose semi-working code, but you gain insight about the problem and the code. In the end, the balance is positive. The code is better.

I find it impressive that if you follow the path, the result is really clean, simple and expressive code.

I find it interesting that if you follow the path, your code may already solve many of the subsequent challenges of Code Retreats. Things like:

- small methods
- no conditionals
- no naked data structures
- no primitive classes

Here are the main classes of my Game of Life so far:
<!--more-->

```ruby
class GOL
  attr_reader :world

  def initialize
    @world = World.new
  end

  def add(another_living_cell_location)
    @world.add(another_living_cell_location)
  end

  def remove(living_cell_location)
    @world.delete(living_cell_location)
  end

  def tick
    will_die   = @world.unsustainable_locations
    will_spawn = @world.germinal_locations
    tock(will_die, will_spawn)
  end

  private

  def tock(dead_cells, born_cells)
    dead_cells.each { |cell| remove(cell) }
    born_cells.each { |cell| add(cell) }
  end
end

class World < Set
  alias_method :number_of_living_cells, :size

  def unsustainable_locations
    select { |loc| !survives?(loc) }
  end

  def germinal_locations
    potential_perimeter.select { |loc| fertile?(loc) }
  end

  private

  def potential_perimeter
    possible_locations = Set.new
    each { |loc| possible_locations |= loc.adjacents }
    possible_locations.subtract self
  end

  def fertile?(location)
    alive_nearby(location) == 3
  end

  def survives?(location)
    alive_nearby(location).between?(2, 3)
  end

  def alive_nearby(location)
    location.adjacents.count { |loc| include?(loc) }
  end
end

Location = Struct.new(:x, :y) do
  def ==(other)
    to_a == other.to_a
  end
  alias_method :eql?, :==

  def adjacents
    perimeter_coordinates.map { |coords| Location.new(*coords) }
  end

  protected

  def perimeter_coordinates
    [x + 1, x, x - 1].product([y - 1, y, y + 1]) - [[x, y]]
  end

  def hash
    to_a.hash
  end
end
```
